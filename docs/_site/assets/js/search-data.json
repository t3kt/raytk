{"0": {
    "doc": "About RayTK",
    "title": "Downloads",
    "content": "Download the toolkit tox file from the GitHub repository releases. ",
    "url": "/raytk/#downloads",
    "relUrl": "/#downloads"
  },"1": {
    "doc": "About RayTK",
    "title": "Background",
    "content": "RayTK is a ground-up rewrite of a previous similar project, which was based on Patrik Lechner’s TDRaymarchToolkit, which was based on hg_sdf and the work of Inigo Quilez. ",
    "url": "/raytk/#background",
    "relUrl": "/#background"
  },"2": {
    "doc": "About RayTK",
    "title": "Author",
    "content": "RayTK was created by Tekt, a programmer and media artist based out of Los Angeles. Check out Instagram to see Tekt’s latest work. ",
    "url": "/raytk/#author",
    "relUrl": "/#author"
  },"3": {
    "doc": "About RayTK",
    "title": "About RayTK",
    "content": "RayTK is a library of TouchDesigner components that construct raymarching shaders (and other types of shaders) with networks of COMPs using the TouchDesigner network editor. RayTK consists of a set of operator (ROP) components, and tools for working with them. The goal of RayTK is to allow artists without a strong knowledge of GLSL to render raymarched scenes, using the familiar elements of the TouchDesigner network editor. Raymarching has been around for a long time, but it is very different from traditional rendering, and it requires a strong knowledge of GLSL and vector math. ",
    "url": "/raytk/",
    "relUrl": "/"
  },"4": {
    "doc": "Addons",
    "title": "RayTK Addons",
    "content": "RayTK addons are additional components that extend the toolkit’s functionality. They are not included in the core toolkit, but are available as separate downloads available from Tekt’s Patreon. Versions of addons line up with versions of the main toolkit, and are only compatible with that same version of RayTK. Like the main toolkit, each addon is a tox file that can be added to a project. They require the main toolkit to also be loaded in order to use tools like the palette to create operators from the addon. Important Note: Read the licensing and rules section at the bottom of this page! . ",
    "url": "/raytk/guide/addons/#raytk-addons",
    "relUrl": "/guide/addons/#raytk-addons"
  },"5": {
    "doc": "Addons",
    "title": "RayTKVolumes",
    "content": "RayTKVolumes is a collection of components that make it easier to work with volumes in RayTK. Volumes are sort of part way between an SDF and a field. They have a density value at each point in space as well as some SDF properties like a color attribute. They can be created from SDFs, fields, or even 3D textures. Many operators in the main toolkit support volumes, especially transformations. There are a few areas: . | Converting RayTK content (SDFs, fields, volumes, etc.) into 3D textures, which can be used with Josef Pelz’s T3D. | Creating and modifying volumes | Rendering them use a specialized version of the RayTK renderer that supports things like clouds that are fields of density rather than hard surfaces. | . A typical scene could do something like this: . | Use RayTK SDF operators to create some scene content, combining and transforming the SDFs. | That gets converted to a 3D texture using the texture3dRender operator. | Use T3D to process that texture, doing things that RayTK can’t, like feedback. | Either using T3D’s surface operator to render it. | Or bringing it back into RayTK with a texture3dVolume and render it as a cloud using volumetricRaymarchRender3D. | . ",
    "url": "/raytk/guide/addons/#raytkvolumes",
    "relUrl": "/guide/addons/#raytkvolumes"
  },"6": {
    "doc": "Addons",
    "title": "RayTKAbstractions",
    "content": "The RayTKAbstractions addon is a collection of components that take common patterns and workflows in RayTK and package them up into more user-friendly operators, or add enhanced functionality to existing operators. ",
    "url": "/raytk/guide/addons/#raytkabstractions",
    "relUrl": "/guide/addons/#raytkabstractions"
  },"7": {
    "doc": "Addons",
    "title": "Licensing and Rules",
    "content": "RayTK addons are available through Patreon subscriptions. An active subscription is required to download the latest versions of the addons. But like the main toolkit, once you create operators from the addon, they can be used in any project without needing to have the addon package loaded. Important Note: The licensing and policies around the addons will likely be changing, including rules about what you are or are not allowed to share with other people or post publicly. The policy as of this release is: . | You can share files that contain operators created from the addon. | You CANNOT share files that contain the entire addon package. | . If users break that rule, even if it’s unintentional, there may need to be more restrictions on accessing and using the addons. But it’s better for everyone if we avoid having to do that. What this means is that you CANNOT do this: . | Open a TD project | Load the toolkit and the addon into the project | Create some content using addon operators | Save the project | Share that project file (.toe) with someone else | . Doing that would include the entire addon package in the project file, which is not allowed. Instead, you should do this: . | Open a TD project | Load the toolkit and the addon into the project | Create some content using addon operators | Save the project | Put the content in a COMP, which does not have the addon package inside it | Save that COMP as a .tox file | Share the tox file with someone else | . ",
    "url": "/raytk/guide/addons/#licensing-and-rules",
    "relUrl": "/guide/addons/#licensing-and-rules"
  },"8": {
    "doc": "Addons",
    "title": "Addons",
    "content": " ",
    "url": "/raytk/guide/addons/",
    "relUrl": "/guide/addons/"
  },"9": {
    "doc": "Concepts",
    "title": "Types of Components",
    "content": ". | ROPs - create “definitions” for operations. | OutputOPs - take in “definitions” and use them to build and run a shader. | PostOPs - image filters or processors that are designed to work with the TOP streams from OutputOPs. | RComps - helper components that work with other operators. | . ",
    "url": "/raytk/guide/concepts/#types-of-components",
    "relUrl": "/guide/concepts/#types-of-components"
  },"10": {
    "doc": "Concepts",
    "title": "Definitions",
    "content": "Definitions are chunks of data that come out of ROPs and are passed down chains of ROPs in a scene. They are represented as DAT tables. Unless you are developing the core of the RayTK library itself, you will never need to deal directly with the contents of the Definitions. They should be treated as an opaque data type. They’re just the “thing” that comes out of a ROP and goes into other ops. Each Definition describes a GLSL function and its dependencies (such as parameters). The functions take in coordinates and other information, and produce some kind of value, such as a color, or the distance to a surface. So in a sense, Definitions have sub-types, such as “Definition of a function that looks up colors based on 3D coordinates”, or “Definition of a function that decides what direction to shoot a ray based on 2D coordinates”. ",
    "url": "/raytk/guide/concepts/#definitions",
    "relUrl": "/guide/concepts/#definitions"
  },"11": {
    "doc": "Concepts",
    "title": "ROPs",
    "content": "Each ROP produces a single Definition table, which describes that ROP’s function code and properties. Many ROPs take inputs of other Definition tables, which it merges with its own and sends it back out of the ROP. For example, a rotate ROP takes in an input and inserts its own definition of a function that rotates coordinates and then does whatever that input describes. ",
    "url": "/raytk/guide/concepts/#rops",
    "relUrl": "/guide/concepts/#rops"
  },"12": {
    "doc": "Concepts",
    "title": "OutputOPs",
    "content": "A Definition on its own is just a chunk of data in a DAT. To render a scene, the Definition needs to be fed into an OutputOP, such as raymarchRender3d. These components take in one or more Definition inputs, construct a shader based on those inputs, and run it in a GLSL TOP, to produce various types of image outputs. They are equivalent to Render TOPs, which take in some Geometry COMPs and render them to an image. As the name suggests, raymarchRender3d uses the ROP network to build a raymarching shader, producing a rendered view of your scene, from some sort of camera. ",
    "url": "/raytk/guide/concepts/#outputops",
    "relUrl": "/guide/concepts/#outputops"
  },"13": {
    "doc": "Concepts",
    "title": "Execution Chain",
    "content": "The Output ROP at the end of a chain of ROPs generates a shader along with things like uniforms, textures, etc. It then runs that shader in a GLSL TOP and outputs the results. Each type of Output ROP has a block of GLSL called the “body”, which contains the main() function. The body code will call functions from input ROPs for various purposes. In the case of render2d (when using a vector field input ROP), it calls the input function once per pixel, to determine the color of that pixel. In the case of raymarchRender3d, the main scene input is executed once per each step of the rays. In addition to the scene input, raymarchRender3d has an input for a camera function, which called for each pixel of output to determine where the ray goes, and a light function that is called by materials to determine colors. ",
    "url": "/raytk/guide/concepts/#execution-chain",
    "relUrl": "/guide/concepts/#execution-chain"
  },"14": {
    "doc": "Concepts",
    "title": "Coordinate Types",
    "content": "There are several types of coordinates that a ROP can use: . | float: 1D coordinates, which can be used for 1D vector fields. | vec2: 2D coordinates, which are used in 2D SDFs, texture lookups, and screen UV coordinates. | vec3: 3D coordinates, which are the main coordinate type for SDFs and raymarching. | . ",
    "url": "/raytk/guide/concepts/#coordinate-types",
    "relUrl": "/guide/concepts/#coordinate-types"
  },"15": {
    "doc": "Concepts",
    "title": "Return Types",
    "content": "There are several types of data that a ROP function can return, including: . | Sdf: An SDF result, including surface distance, material settings, and other properties. | float: A single floating point value. These can be used to drive the parameters of other ROPs, such as applying different amounts of rotation for different points in space. | vec4: A 4-part vector value. These can be used to drive the parameters of other ROPs, such as applying colors based on position in space. | Ray: A position and direction. These are returned by camera ROPs, to determine what direction the ray should march for each pixel of the output. | Light: A point in space, and an amount of color. These are returned by light ROPs. | . ",
    "url": "/raytk/guide/concepts/#return-types",
    "relUrl": "/guide/concepts/#return-types"
  },"16": {
    "doc": "Concepts",
    "title": "Context Types",
    "content": "Contexts are a secondary package of information that can be passed to ROPs along with the coordinates. Certain special operators access and use this information for a variety of purposes. Each type of context is used in different scenarios during the shader’s rendering process. | Context: This is the default type. It is used when evaluating SDFs in raymarching (basically anything hooked up to the first input), and when choosing the pixel color in a 2D renderer. Many of the other context types include a copy of this along with other info. | MaterialContext: Used by material ROPs when deciding what color to choose for a point on the surface of a shape. It includes: . | The Sdf surface hit | The surface normal. | The Context used when producing that hit. | The Ray from the camera that hit the surface. | The Light that the material should use. | . | CameraContext: Used in raymarching when deciding where the camera ray should point for a pixel of output. It includes: . | The resolution of the output. | . | LightContext: Used in raymarching when deciding where the light is and what color it emits. It includes: . | The Sdf surface hit | The surface normal. | . | . ",
    "url": "/raytk/guide/concepts/#context-types",
    "relUrl": "/guide/concepts/#context-types"
  },"17": {
    "doc": "Concepts",
    "title": "Concepts",
    "content": "RayTK is a collection of several types of components, which can be placed into scenes, and a set of tools for working with those components. ",
    "url": "/raytk/guide/concepts/",
    "relUrl": "/guide/concepts/"
  },"18": {
    "doc": "Contact",
    "title": "Contacting the RayTK Developers",
    "content": "RayTK is a creation of Tekt from Immerse Studio. There are a few ways to reach out if you want to discuss the toolkit or ask questions: . | Create a GitHub issue | Instagram: t3kt | Facebook: int3kt | The #raytk channel in the TouchDesigner Discord | Tagging @tekt in a post on the TouchDesigner Forum | Email: tekt@immerse.studio | . ",
    "url": "/raytk/guide/contact/#contacting-the-raytk-developers",
    "relUrl": "/guide/contact/#contacting-the-raytk-developers"
  },"19": {
    "doc": "Contact",
    "title": "Contact",
    "content": " ",
    "url": "/raytk/guide/contact/",
    "relUrl": "/guide/contact/"
  },"20": {
    "doc": "Fields",
    "title": "Fields",
    "content": "Fields are operators that are similar to SDFs, but instead of producing hits on surfaces, they come up with either 1 or 4 numeric values (either a float or a vec4). Other operators use fields to control behavior depending on where a point is in space. For example, you can recreate what the twist operator does using a rotate with a value field controlling the Rotate parameter, applying different amounts of rotation at different coordinates along the axis. ",
    "url": "/raytk/guide/fields/",
    "relUrl": "/guide/fields/"
  },"21": {
    "doc": "Fields",
    "title": "Field Types",
    "content": "There are two different kinds of data that a field can produce: . | Float: a single numeric value. | Vector: 4 numeric values. | . ROPs that use fields may support one or both of those types. ",
    "url": "/raytk/guide/fields/#field-types",
    "relUrl": "/guide/fields/#field-types"
  },"22": {
    "doc": "Fields",
    "title": "How Fields are Used by ROPs",
    "content": "Operators like rotate use the provided field to decide how much rotation to apply at each position in space. The rotate asks the field what the values are for the current position and gets back either a single number of a set of 4 (a vector). If it’s a single number, and the rotate is using the mode that spins around a single axis, that single number is applied to the rotation around the axis. If it’s a vector and rotate is using the Euler XYZ mode, the first number is applied to X rotation, the second to Y, the third to Z, and the fourth is ignored. ",
    "url": "/raytk/guide/fields/#how-fields-are-used-by-rops",
    "relUrl": "/guide/fields/#how-fields-are-used-by-rops"
  },"23": {
    "doc": "Fields",
    "title": "Position-Based Fields",
    "content": "The simplest case of a position-based field is positionField. It takes in the provided coordinates, and just returns them (along with an extra 0 to fill the vector). The pointDistanceField is similar, but instead it returns the distance between the provided coordinates and some other point in space. Unlike positionField, it returns just a single value (the distance). Most filters that are used for SDFs can also work for fields that use positions. If you had a positionField and you passed that through a translate would return values that are offset by some distance. ",
    "url": "/raytk/guide/fields/#position-based-fields",
    "relUrl": "/guide/fields/#position-based-fields"
  },"24": {
    "doc": "Fields",
    "title": "Non-Position Fields",
    "content": "While fields make use of the parameters that are passed to them, they don’t necessarily have to. Some operators like lfoField ignore the provided coordinates and use other sources of data to produce values. In the case of lfoField, it uses the current time from either the global application time or from the associated timeline. ",
    "url": "/raytk/guide/fields/#non-position-fields",
    "relUrl": "/guide/fields/#non-position-fields"
  },"25": {
    "doc": "Fields",
    "title": "Ways That Coordinates are Passed to Fields",
    "content": "When an operator is using a field input, it provides some form of coordinates to that field. The most common case of this is to just pass along the position where that operator is being evaluated. In most (or all) cases where the field accepts the same type of coordinates as the operator that is using it, that same position is being passed along. In other cases, an operator might accept a field that takes a different type of coordinates than what the operator uses. These operators will provide the field with some other type of value as the coordinates. Each operator that does this handles it differently. For example, if a field using 1D coordinates is passed into mobiusRingSdf, it will give it the angle of the current point around the axis of the ring. This can be used with a waveField to vary the thickness of the ring with a sine wave that wraps around the ring’s axis. Operators that support these types of inputs will document which types of coordinates they support and what kind of values they use for each type. ",
    "url": "/raytk/guide/fields/#ways-that-coordinates-are-passed-to-fields",
    "relUrl": "/guide/fields/#ways-that-coordinates-are-passed-to-fields"
  },"26": {
    "doc": "Getting Started With RayTK",
    "title": "Getting Started With RayTK",
    "content": " ",
    "url": "/raytk/guide/getting-started/",
    "relUrl": "/guide/getting-started/"
  },"27": {
    "doc": "Getting Started With RayTK",
    "title": "Download the Library",
    "content": "The first step to using RayTK is to download the latest tox file, from the repository. Note that there are many source files in the repository itself, but these are only needed for development purposes. Feel free to take a look through them if you want, but if you only want to use the library rather than modify it, use the release tox file. ",
    "url": "/raytk/guide/getting-started/#download-the-library",
    "relUrl": "/guide/getting-started/#download-the-library"
  },"28": {
    "doc": "Getting Started With RayTK",
    "title": "Load the Library",
    "content": "Drag the tox file into the project. ",
    "url": "/raytk/guide/getting-started/#load-the-library",
    "relUrl": "/guide/getting-started/#load-the-library"
  },"29": {
    "doc": "Getting Started With RayTK",
    "title": "Creating a Network",
    "content": "To create your first ROP, use the keyboard shortcut alt + r to open up the RayTK Palette. It will show a list of available ROPs, organized into categories. You can search by typing a name. This popup is like the main TouchDesigner “OP Create Dialog” (using tab), but it shows the available ROPs rather than the standard TouchDesigner OPs. | Choose a boxFrameSdf, and a new COMP will be created in the network editor. | Create a raymarchRender3d and connect the output of your boxFrameSdf to the input of the raymarchRender3d. | Connect a Null TOP to the first output of raymarchRender3d. | Play around with the parameters of the boxFrameSdf. | . You’ve just created your first RayTK network! . The boxFrameSdf is an SDF (signed distance function) operator, which is how you define geometry. It’s equivalent to SOPs like Sphere, Box, etc. The raymarchRender3d is an “Output OP” or renderer. It’s equivalent to a Render TOP. It generates and runs a shader that renders the scene. ",
    "url": "/raytk/guide/getting-started/#creating-a-network",
    "relUrl": "/guide/getting-started/#creating-a-network"
  },"30": {
    "doc": "Getting Started With RayTK",
    "title": "Camera and Light",
    "content": "By default, the renderer uses a built-in camera and light. To override those, attach camera and light operators. | Create a lookAtCamera and connect it to the second (“Camera”) input of the raymarchRender3d. | Create a pointLight and connect it to the third (“Light”) input of the raymarchRender3d. | Try changing the settings of the lookAtCamera and pointLight. | . ",
    "url": "/raytk/guide/getting-started/#camera-and-light",
    "relUrl": "/guide/getting-started/#camera-and-light"
  },"31": {
    "doc": "Getting Started With RayTK",
    "title": "Filters",
    "content": "Now that you have a complete render setup, you can use filters to modify the SDF. | Add a twist between the boxFrameSdf and the raymarchRender3d. | Adjust the “Amount” parameter and watch the box twist in the output. | Try changing the “Axis” parameter to twist around another axis. | . You’ve just created your first “filter” ROP! It modifies the behavior of another ROP. ",
    "url": "/raytk/guide/getting-started/#filters",
    "relUrl": "/guide/getting-started/#filters"
  },"32": {
    "doc": "Getting Started With RayTK",
    "title": "Materials",
    "content": "By default, the renderer uses a built-in material. To override it, insert a material operator. | Add a basicMat between the twist and the raymarchRender3d. | Try out different color settings. | . You’ve just created your first “material” ROP. It assigns a material to an SDF, which is used to determine what colors it should use. ",
    "url": "/raytk/guide/getting-started/#materials",
    "relUrl": "/guide/getting-started/#materials"
  },"33": {
    "doc": "Getting Started With RayTK",
    "title": "Cleanup",
    "content": "Now that you’ve set up your scene, you don’t need to keep the main toolkit tox loaded in the project if you don’t want to. All the ROPs are totally self-contained! That means that if you save out scenes as tox files, you can drop those into any project and they’ll work, without having to load the toolkit itself. However some editing tools such as the Palette and the Inspector are only available if the toolkit itself is loaded . ",
    "url": "/raytk/guide/getting-started/#cleanup",
    "relUrl": "/guide/getting-started/#cleanup"
  },"34": {
    "doc": "The Inspector",
    "title": "The Inspector",
    "content": "The inspector is a tool that can be used to examine RayTK operators. The inspector provides a way to “look inside” an OP. Because the ROPs are not a natively supported part of TouchDesigner, they don’t have inline previews like TOPs, SOPs, etc. The inspector is intended as an alternative, and adds other toolkit-specific features. :information_source: The TDRaymarchToolkit which was the inspiration for RayTK does support inline previews. It does so by embedding a renderer inside each OP. While great from a user perspective, it can be very costly in terms of performance. Because of the performance and other issues, RayTK made the decision to abandon support for inline previews. ",
    "url": "/raytk/guide/inspector/",
    "relUrl": "/guide/inspector/"
  },"35": {
    "doc": "The Inspector",
    "title": "How to Open the Inspector",
    "content": "All ROPs have a parameter named “Inspect”. Clicking on this parameter will open up an inspector window, pointed at that ROP. Inspecting another ROP will reuse that same window. It is not currently possible to have multiple inspectors. :information_source: Upcoming versions to the toolkit will likely provide other ways to launch the inspector, such as with a keyboard shortcut. ",
    "url": "/raytk/guide/inspector/#how-to-open-the-inspector",
    "relUrl": "/guide/inspector/#how-to-open-the-inspector"
  },"36": {
    "doc": "The Inspector",
    "title": "The Inspector UI",
    "content": ". The inspector window is arranged into several sections: . | Info bar - At the top of the window, the info bar shows properties of the selected ROP. Aside from the path, these are mostly only relevant for development purposes. | Tool bar - Below the info bar, there is a row of buttons to perform various actions, such as showing the selected ROP in the network editor, or resetting the inspector so it deselects the ROP. | Main panel - The main area of the window is separated into several tabs. | Preview - Shows a rendered view of the ROP. | Shader - Shows the full generated shader code. | Params - Details about all the parameters of the ROP and its dependencies. | Validation - A table of warnings and errors about the ROP and its dependencies. | . | Parameters panel - The parameters panel next to the main panel shows parameter editors for the selected ROP and other components. | ROP - The parameters of the selected ROP. | Render - The parameters of the renderer being used, which is either the selected ROP if it is an OutputOP, or a separate renderer that the inspector created. | Camera - The parameters of the camera being used. This can be one of several different cameras depending on the selected ROP and related settings. | Light - The parameters of the light being used, similar to Camera. | . | . ",
    "url": "/raytk/guide/inspector/#the-inspector-ui",
    "relUrl": "/guide/inspector/#the-inspector-ui"
  },"37": {
    "doc": "The Inspector",
    "title": "Inspecting OutputOPs vs. Other ROPs",
    "content": "When inspecting a ROP that is not an OutputOP, the node itself doesn’t have any kind of built-in visualization, so the inspector uses its own internal preview renderers. When inspecting a non-output, the “Render”, “Camera”, and “Light” tabs in the parameters panel point to those items in the inspector’s own renderer. When inspecting an OutputOP, the inspector shows the output of that renderer instead of using a preview renderer. The parameters panel will then point to that renderer and the attached components (camera, light, etc). Preview . The preview tab shows rendered views of the selected ROP. The side bar shows a list of all the available output buffers, such as color, depth, normals, etc. Which buffers are available depends on how the renderer is configured. At the bottom of the side bar, there are settings related to changing how the buffer is viewed, such as normalizing values to a 0..1 range, only showing certain channels, or showing a transparency grid under the image. :information_source: Upcoming versions will have arc-ball mouse control for the camera. Shader . The shader tab shows the full text of the generated shader, and the compiler results, including any errors or warnings. If there are errors, the inspector will show a red bar with an error message. Clicking it will open the shader tab, which will show details about the errors. ",
    "url": "/raytk/guide/inspector/#inspecting-outputops-vs-other-rops",
    "relUrl": "/guide/inspector/#inspecting-outputops-vs-other-rops"
  },"38": {
    "doc": "The Inspector",
    "title": "Tutorial",
    "content": " ",
    "url": "/raytk/guide/inspector/#tutorial",
    "relUrl": "/guide/inspector/#tutorial"
  },"39": {
    "doc": "Iteration",
    "title": "Iteration",
    "content": "Many ROPs effectively repeat the things passed into them multiple times. Iteration is a way for ROPs that feed into those to vary their behavior for different copies. The downstream operator that is repeating things passes “iteration” numbers upstream in the Context that is passed between ROPs, and it will vary those numbers for different copies. Iteration is similar to the “copy stamp” feature in the TouchDesigner Copy SOP, which evaluates its input chain multiple times and makes values available through the fetchStamp() function for parameter expressions. ",
    "url": "/raytk/guide/iteration/",
    "relUrl": "/guide/iteration/"
  },"40": {
    "doc": "Iteration",
    "title": "Operators That Provide Iteration",
    "content": "Various operators are able to provide iteration values to their inputs. Some of them will actually run their input multiple times, with a different value each time (which is costly for performance). For example, radialClone creates multiple copies of its input and merges them together. It has an option to set the iteration values for each of those copies. The instance operator is similar to radialClone. It repeats its input some number of times, and passes the index of that loop as the iteration value, and then merges the results. Unlike radialClone though, it doesn’t apply any transformation on its own. It is designed to be used with operators that consume the iteration and use it to transform the instances. The other more common type of operator that provides iteration values don’t actually run their input multiple times. Instead they decide what iteration value to use based on the position in space. These are much more efficient since they only run their input once. For example, modulo1D repeats space along an axis, which effectively makes an infinite number of “copies” of that shape. It has an option to pass along the index in that series as the iteration value, so the “copy” in the middle will use 0, the one to the right of that will use 1, and so on, and the one to the left uses -1, etc. modulo1D also has an option to produce alternating 0 and 1 as its iteration values. ",
    "url": "/raytk/guide/iteration/#operators-that-provide-iteration",
    "relUrl": "/guide/iteration/#operators-that-provide-iteration"
  },"41": {
    "doc": "Iteration",
    "title": "Operators That Consume Iteration",
    "content": "There are several operators that can make use of the iteration values that are passed to them from downstream ops. The simplest of these is the iterationField, which is a field operator that returns either the whole iteration vec4 or a single part of the iteration (x/y/z/w). It can be used as an input to control the behavior of other ops, such as translate, which has the effect of applying a different amount of translation for each iteration. In that case, it also may need a floatToVector to convert from a single iteration value to the vector that translate expects. The iterationSwitch operator takes two SDF inputs, and toggles between them based on the iteration value. It has options for how it handles values outside the 0 to 1 range (either clamping or toggling back and forth). ",
    "url": "/raytk/guide/iteration/#operators-that-consume-iteration",
    "relUrl": "/guide/iteration/#operators-that-consume-iteration"
  },"42": {
    "doc": "Iteration",
    "title": "Using rangeTransform with Iteration",
    "content": "The rangeTransform applies a transform based on a range of settings. It uses the iteration value to pick where in that range of settings it will use. When used with modulo1D it can do things like rotating each instance incrementally more than the instance before it. When used with instance it can be used to place objects along an arbitrary line in space. It’s important to remember though that this can be much less efficient than modulo1D since it has to run its input separately for each instance. ",
    "url": "/raytk/guide/iteration/#using-rangetransform-with-iteration",
    "relUrl": "/guide/iteration/#using-rangetransform-with-iteration"
  },"43": {
    "doc": "Optimization Tips",
    "title": "Optimizing RayTK Scenes",
    "content": "When creating scenes with RayTK, the performance of the renderer can vary widely depending on a number of different factors. ",
    "url": "/raytk/guide/optimization/#optimizing-raytk-scenes",
    "relUrl": "/guide/optimization/#optimizing-raytk-scenes"
  },"44": {
    "doc": "Optimization Tips",
    "title": "RayTK Is Different Than The Rest of TouchDesigner",
    "content": "There are some core differences in how RayTK operates compared to almost everything else in TouchDesigner. That means that practices that improve performance in regular networks may make RayTK networks perform worse. Conversely some practices that would cause performance problems in regular networks can improve RayTK performance. The most important difference between RayTK and regular TD is that operators don’t contain values. In nearly all other TD operators, each one produces some sort of value, which can then be used by other operators. For a CHOP, the value is a set of channels. For a DAT it’s cells or text. For a TOP it’s an image. When a network is running, on each frame, the TD engine starts by requesting values from certain operators. For each operator, it first makes sure all of the things that operator depends on have been evaluated. If one of those dependencies has already been evaluated, the value within it is reused without having to repeat all the calculations that produced that value. This caching is critical to TouchDesigner performance. For example, let’s say you have an LFO CHOP connected to both a Filter CHOP and a Limit CHOP, and both of those are connected to a Math CHOP that multiplies the channels by each other. When TD is calculating a value for the Math CHOP it first has to get values from the Filter CHOP and the Limit CHOP. When it gets the value for the Filter CHOP, it first has to get the value for the LFO CHOP. Then, when getting a value for the Limit CHOP, it reuses the value it already calculated for the LFO CHOP. But a ROP in a RayTK network has no equivalent of this sort of “value”. Instead, a ROP represents a way to answer a question, such as “what surface is closest to point P?”. During the process of rendering the scene, an operator will be asked many different variations of that question. For example, an SDF is asked about a series of points as a ray marches along. The answers that it produces are different depending on the specific question being asked. The result is that when you connect a ROP to 2 different inputs of another ROP, that first one gets asked twice as many questions, which means twice the performance cost. ",
    "url": "/raytk/guide/optimization/#raytk-is-different-than-the-rest-of-touchdesigner",
    "relUrl": "/guide/optimization/#raytk-is-different-than-the-rest-of-touchdesigner"
  },"45": {
    "doc": "Optimization Tips",
    "title": "Performance Factors",
    "content": "There are a few categories of factors that impact RayTK performance: . | Complex operators that do a lot of calculations when asked for results. | Things that result in operators being asked for results many times. | . ",
    "url": "/raytk/guide/optimization/#performance-factors",
    "relUrl": "/guide/optimization/#performance-factors"
  },"46": {
    "doc": "Optimization Tips",
    "title": "Expensive Operators",
    "content": "There are some operators which are simply expensive. The waveletNoiseField (and other noise-related operators) are good examples of this. Each time they are asked a question, they have to run a large amount of code to come up with a result. The help for some operators will mention that they can be costly. In other cases the best way to identify costly operators is to try swapping them with simpler alternatives and comparing the performance. If you’re using a noiseField for a material color, try swapping in a constantField. If the performance improves dramatically, that means that the noiseField was contributing a lot to the performance cost. Strategy . | Be selective about when you use them, and use simpler alternatives when suitable. | Be extra careful about using them in places where they will be run many times (see below). | . ",
    "url": "/raytk/guide/optimization/#expensive-operators",
    "relUrl": "/guide/optimization/#expensive-operators"
  },"47": {
    "doc": "Optimization Tips",
    "title": "Calculation Multipliers",
    "content": "The most important performance factors are things that result in operators being run many times. For any type of renderer, the resolution will have a major impact on performance. Remember that the shader will be running its whole process for every pixel, in parallel. The more pixels, the more GPU resources that will consume. raymarchRender3d . When using raymarchRender3d, the whole network connected to the first input on the renderer is used to calculate an SDF result. The renderer runs that whole network once for every step along a ray’s path. That means that if the SDF network costs C, marching a ray costs C * S, where S is the number of marching steps. Once a ray hits a surface, it calculates the color. To do that, it runs the associated material, which includes everything connected to secondary inputs on the material ROP. For example, basicMat could have a noiseField connected to its “Base Color Field” input. That noiseField would need to be run to come up with that color. If the material is using surface normals (which almost all materials do), the renderer has to run the whole SDF network 4 more times. It does this at slightly offset positions in order to calculate the slope of the surface. If the material is using lighting (which almost all do), the renderer has to run the lighting network once. If the material is using shadows, the renderer does a whole additional ray march to check if the light is blocked (shadowed) for that point on the surface. That means another multiple of the cost of a ray march. If the material is using reflection, for each reflection pass, the renderer does an entire render pass, which includes a ray march, and also evaluating a material, possibly a shadow ray march, and so on. If the renderer is using anti-aliasing, it runs that entire process (which may include numerous ray marches) multiple times, in order to average the results. So overall, the cost of the renderer would be: . {antialias steps} * ( {camera cost} + ( (1 + {reflection passes}) * ( ({SDF cost} * {march steps}) + ({SDF cost} * {march steps}) // for shadow + ({SDF cost} * 4) // for normals + {material cost} + {light cost} ) ) ) . Within an SDF network, certain operators like radialClone will run their input (and everything upstream) multiple times. Strategies . From most effective to least: . | Reduce antialiasing as much as you can without it looking bad | Reduce resolution | Avoid reflection if possible, and if so, reduce the number of reflection passes | Avoid using shadows if possible | Simplify SDF . | Avoid operators like radialClone, instance, flip (when using merging) | . | Simplify material | Simplify light | Simplify camera | . ",
    "url": "/raytk/guide/optimization/#calculation-multipliers",
    "relUrl": "/guide/optimization/#calculation-multipliers"
  },"48": {
    "doc": "Optimization Tips",
    "title": "Operators That Repeat Work (or might seem like they do)",
    "content": "Cheap . | Common . | mirrorAxes | mirrorOctant | mirrorQuadrant | modulo1D | modulo2D | modulo3D | moduloPolar | reflect | . | Unusual . | geometricSeriesSquareTile | logPolarRepeat | moduloDistance | moduloSpherical | moduloLine | quadTreeRepeat | rectangleRepeat | . | . Expensive . | Common . | gridClone → modulo2D | instance | linearClone → modulo1D | radialClone → moduloPolar | . | Unusual . | circularRepeat but only 4x regardless of spacing/radius | flip with merge enabled | instanceField | iteratedTransform with accumulation enabled | . | . ",
    "url": "/raytk/guide/optimization/#operators-that-repeat-work-or-might-seem-like-they-do",
    "relUrl": "/guide/optimization/#operators-that-repeat-work-or-might-seem-like-they-do"
  },"49": {
    "doc": "Optimization Tips",
    "title": "Optimization Tips",
    "content": " ",
    "url": "/raytk/guide/optimization/",
    "relUrl": "/guide/optimization/"
  },"50": {
    "doc": "Output Buffers",
    "title": "Output Buffers",
    "content": "Output buffers are TOP streams that come out of an OutputOP. They allow a single OutputOP to produce multiple types of data for each pixel. See TouchDesigner documentation for details. Different types of renderers provide different types of output buffers. Each type of renderer has a “main” output, such as color for raymarchRender3d. Output ops have parameters that can enable and disable various outputs. ",
    "url": "/raytk/guide/output-buffers/",
    "relUrl": "/guide/output-buffers/"
  },"51": {
    "doc": "Output Buffers",
    "title": "Accessing Output Buffers",
    "content": "There are several ways to access output buffers. First, OutputOPs have outputs for some of the buffers that they produce. raymarchRender3d, for example, has outputs for color, normals, depth, and so on. However not all of the possible buffers are available as outputs from the ROP itself. To access those, you can use renderSelect. It has a parameter that takes in a reference to an OutputOP, and a menu parameter that lets you choose from one of the possible types of outputs. :warning: If the selected buffer produces empty output, either that buffer needs to be enabled on the OutputOP, or that type of buffer isn’t offered by that OutputOP at all. Last, certain types of buffers have specialized components that access output buffer data and provide additional associated functionality. For example, depthMap accesses the “depth” buffer, and has options for scaling and adjusting the resulting depth map. Similarly, worldPosMap accesses the “world position” buffer, and has options for adjusting the resulting position map. ",
    "url": "/raytk/guide/output-buffers/#accessing-output-buffers",
    "relUrl": "/guide/output-buffers/#accessing-output-buffers"
  },"52": {
    "doc": "Output Buffers",
    "title": "The Inspector",
    "content": "The Inspector is a great tool for exploring output buffers. It shows a list of all the available buffers for the selected ROP and shows the contents of the buffers along with tools for examining the values in them. ",
    "url": "/raytk/guide/output-buffers/#the-inspector",
    "relUrl": "/guide/output-buffers/#the-inspector"
  },"53": {
    "doc": "Output Buffers",
    "title": "Tutorial",
    "content": " ",
    "url": "/raytk/guide/output-buffers/#tutorial",
    "relUrl": "/guide/output-buffers/#tutorial"
  },"54": {
    "doc": "The Palette",
    "title": "The RayTK Palette",
    "content": "The palette is the main tool for creating RayTK operators. The palette can be opened using the ALT+R shortcut. The shortcut can be customized by changing the Keyboard Shortcut parameter on the main toolkit COMP. The palette can also be opened by clicking the Show Palette parameter on the toolkit COMP. By default, the palette closes after creating an operator, but it can be pinned open using the button on the top right next to the close button. ",
    "url": "/raytk/guide/palette/#the-raytk-palette",
    "relUrl": "/guide/palette/#the-raytk-palette"
  },"55": {
    "doc": "The Palette",
    "title": "Parts of the Palette",
    "content": ". | Toolkit version. | Pin toggle to keep the palette open after creating operators. | Button to close the palette. | Shortcut for an operator that can be entered into the search field. | An operator. Clicking this will create one of these operators. | Thumbnail for an operator (if available). This can be shown or hidden (for a more condensed layout) using the thumbnails toggle. | An operator category. Clicking this will expand or collapse a category of operators in the list. | Search field. Searching will match operator names, operator keywords, shortcuts (e.g. sph for sphereSdf), and abbreviations (e.g. fgr for functionGraphRender). | Button to clear the search field. | Filter toggles that show/hide: . | Alpha operators: experimental operators, which are only available in experimental releases. | Beta operators: operators that work, but are still in development and may change in future releases. | Deprecated operators: operators that have been replaced by newer alternatives and may be removed in future releases. | . | Button to toggle showing thumbnails. Hiding thumbnails condenses the layout of the list. | Toggle to expand/collapse the help section. | Help section which shows a description of the highlighted operator (if available). | . ",
    "url": "/raytk/guide/palette/#parts-of-the-palette",
    "relUrl": "/guide/palette/#parts-of-the-palette"
  },"56": {
    "doc": "The Palette",
    "title": "Keyboard Interaction",
    "content": "When the palette opens, keyboard focus is automatically put into the filter field, so you can search for operators by typing, without having to click on anything. Using the up/down arrow keys will move focus in the main list, stepping through whatever operators are shown. Using the enter key will create the selected operator (and close the palette if it isn’t pinned). ",
    "url": "/raytk/guide/palette/#keyboard-interaction",
    "relUrl": "/guide/palette/#keyboard-interaction"
  },"57": {
    "doc": "The Palette",
    "title": "The Palette",
    "content": " ",
    "url": "/raytk/guide/palette/",
    "relUrl": "/guide/palette/"
  },"58": {
    "doc": "Editor Tools",
    "title": "Editor Tools",
    "content": "RayTK’s editor tools are a set of actions that can be performed on selected operators. They’re available in a menu that can be opened with the shortcut alt+shift+r, as long as the main toolkit tox is loaded in the project. The set of tools shown in the menu depends on what is selected in the network. For example, when a raymarchRender3D is selected, the menu will include options to add a camera or a light. ",
    "url": "/raytk/guide/tools/",
    "relUrl": "/guide/tools/"
  },"59": {
    "doc": "Troubleshooting",
    "title": "Troubleshooting",
    "content": "If you encounter problems working with RayTK, there are a few ways to investigate the issue. If there isn’t a clear solution, don’t hesitate to reach out for help! . ",
    "url": "/raytk/guide/troubleshooting/",
    "relUrl": "/guide/troubleshooting/"
  },"60": {
    "doc": "Troubleshooting",
    "title": "Render/Shader Errors vs Other Types of Bugs",
    "content": "There are two categories of problems that you might encounter when working with the toolkit. | Render/shader errors. | Unexpected behavior. | . Render/Shader Errors . If the renderer in your scene is producing a red and blue checkerboard pattern, it means that there’s an error in the shader that’s rendering the scene. This is either because the scene is configured incorrectly, or because the toolkit is broken in some manner. In this case there are some tools you can use to identify the error. Unexpected Behavior . If you are getting some sort of non-checkerboard output from the renderer, but it isn’t what you want it to be, that falls into the “unexpected behavior” category. Tracking down the cause of these issues may be a bit more difficult. They may be due to bugs in the toolkit itself, or because of misunderstandings about how the toolkit works. Either of those cases, you should still report the issue! . If it’s a misunderstanding, that likely means that either the toolkit is not intuitive, or that the documentation isn’t clear. Both of those are situations that should be reported and addressed! . ",
    "url": "/raytk/guide/troubleshooting/#rendershader-errors-vs-other-types-of-bugs",
    "relUrl": "/guide/troubleshooting/#rendershader-errors-vs-other-types-of-bugs"
  },"61": {
    "doc": "Troubleshooting",
    "title": "OP Validation Errors / Warnings",
    "content": "RayTK operators can detect many types of issues when they are connected to each other. Type Errors . The most common type of issue is when an operator’s input is connected to the wrong type of operator. In some cases this is straightforward. It doesn’t make sense to combine a boxSdf and a lookAtCamera, or to use a pointLight as the “Radius Field” input of a sphereSdf. In other cases, it’s a matter of how a particular operator is configured. If a noiseField operator is set to use 3D coordinates, but it’s connected to something that uses 2D coordinates, that will be treated as an error. In cases like that, you can often change the settings of the upstream operators so that they meet the requirements of what they’re connected to. ",
    "url": "/raytk/guide/troubleshooting/#op-validation-errors--warnings",
    "relUrl": "/guide/troubleshooting/#op-validation-errors--warnings"
  },"62": {
    "doc": "Troubleshooting",
    "title": "The Inspector",
    "content": "The Inspector is a useful tool for investigating issues in scenes. To open it, select an operator and click the Inspect parameter. Start by doing that on the renderer at the end of a scene network. If you’re dealing with a render/shader error, there are two tabs that can provide helpful information: . | Validation | Shader | . The Validation Tab . The “Validation” tab shows any detected issues in the operator that you selected as well as in any operator upstream from that one in your scene. These are the same types of errors that will often show up on individual operators in the scene, but collected into a list with details. In some cases, an error may not be shown in the network editor on an operator, but will still show up in the inspector. The Shader Tab . The “Shader” tab shows the generated shader that the renderer is using, along with any error messages that TouchDesigner and/or the GPU driver produced when trying to compile and run the shader. ",
    "url": "/raytk/guide/troubleshooting/#the-inspector",
    "relUrl": "/guide/troubleshooting/#the-inspector"
  },"63": {
    "doc": "Troubleshooting",
    "title": "Reporting Issues on GitHub",
    "content": "The best way to get help with RayTK is to report the issue on the GitHub. You may want to try searching through existing issues to see if your bug has been reported already. If it has, you can add a comment with details about how it manifested in your case. Or you can just file a new issue which can be de-duplicated later if needed. Make sure to include the following information in your issue report: . | RayTK version (e.g. 0.15) | Information from the inspector . | Validation errors/warnings | Shader compile errors/warnings | . | OS (e.g. Windows 10, macOS) | GPU (e.g. Nvidia GTX 1080, AMD Radeon Pro 575) | GPU driver version . | How to find your driver version | . | . ",
    "url": "/raytk/guide/troubleshooting/#reporting-issues-on-github",
    "relUrl": "/guide/troubleshooting/#reporting-issues-on-github"
  },"64": {
    "doc": "Troubleshooting",
    "title": "Requesting Features",
    "content": "You can also create a GitHub issue to request features or suggest improvements. Please do this if you have ideas! We are always open to suggestions. There may also already be a way to do what you’re trying to do that might just not be documented well. When requesting a feature/improvement, you don’t need to include all the details about your setup unless it seems relevant. ",
    "url": "/raytk/guide/troubleshooting/#requesting-features",
    "relUrl": "/guide/troubleshooting/#requesting-features"
  },"65": {
    "doc": "Troubleshooting",
    "title": "Reaching Out to the Developers",
    "content": "If you’d like to talk to the developers about the toolkit, feel free to reach out! . ",
    "url": "/raytk/guide/troubleshooting/#reaching-out-to-the-developers",
    "relUrl": "/guide/troubleshooting/#reaching-out-to-the-developers"
  },"66": {
    "doc": "Tutorials",
    "title": "RayTK Tutorials",
    "content": "All the RayTK tutorials are available in this YouTube playlist. ",
    "url": "/raytk/guide/tutorials/#raytk-tutorials",
    "relUrl": "/guide/tutorials/#raytk-tutorials"
  },"67": {
    "doc": "Tutorials",
    "title": "RayTK Intro Series (2022)",
    "content": " ",
    "url": "/raytk/guide/tutorials/#raytk-intro-series-2022",
    "relUrl": "/guide/tutorials/#raytk-intro-series-2022"
  },"68": {
    "doc": "Tutorials",
    "title": "Tutorials",
    "content": " ",
    "url": "/raytk/guide/tutorials/",
    "relUrl": "/guide/tutorials/"
  },"69": {
    "doc": "Updating Scenes",
    "title": "Updating Toolkit Versions",
    "content": "When a new version of RayTK is available, if you want to use it with older scenes, there’s a tool that lets you update the operators in-place. For very early versions (before 0.11), this feature is not available. You can have older RayTK operators in a project alongside newer ones, but they can’t be connected ops from different versions. | Save a backup of the project. | Remove the old toolkit COMP from your project. | Download the new toolkit tox and drop it into your project. | Select all RayTK operators in your scene. That means any operator that has the RayTK-style viewer image on the COMP, as well as any RayTK panel COMPs like raymarchPreviewPanel. | In the parameter panel, on the first page, click “Update OP” | . ",
    "url": "/raytk/guide/update/#updating-toolkit-versions",
    "relUrl": "/guide/update/#updating-toolkit-versions"
  },"70": {
    "doc": "Updating Scenes",
    "title": "Warning",
    "content": "It is possible that parts of the scene may behave differently or might get disconnected (which is why backups are important). One particularly common issue is a change in the scaling of the Period parameter in waveField and similar operators. Early versions of the toolkit incorrectly scaled the period to much larger values than they were supposed to. So you may need to increase those settings after the update. ",
    "url": "/raytk/guide/update/#warning",
    "relUrl": "/guide/update/#warning"
  },"71": {
    "doc": "Updating Scenes",
    "title": "Updating Scenes",
    "content": " ",
    "url": "/raytk/guide/update/",
    "relUrl": "/guide/update/"
  },"72": {
    "doc": "Variables",
    "title": "Variables",
    "content": "Variables are a way for operators to provide additional information to other operators in the scene. For example, the modulo1D operator repeats slices of space along an axis. It offers a variable indicating which slice is being rendered, so that its input can vary settings per-slice. Another example is the assignColor operator, which adds a color setting to an SDF result. It offers a variable to access the SDF result produced by its first input, so that the “Color Field” input can base the color on something like the SDF’s UV coordinates. Variables can be created in one of two ways: . | Selecting the operator providing the variable, and using the editor tools menu (alt+shift+r), with the “Reference Variable” sub-menu. | Clicking one of the buttons on the providing operator’s “Variables” parameter page. | . Doing this will create a variableReference operator, which access the value of the selected variable from the selected operator. This operator produces whatever type of value that variable uses, either in its entirety or just a single field within that value. For example, a vector variable can be accessed to produce either the whole vector, or just the Y part of the vector, depending on the settings on the variableReference. ",
    "url": "/raytk/guide/variables/",
    "relUrl": "/guide/variables/"
  },"73": {
    "doc": "Variables",
    "title": "Tutorial Video",
    "content": " ",
    "url": "/raytk/guide/variables/#tutorial-video",
    "relUrl": "/guide/variables/#tutorial-video"
  },"74": {
    "doc": "basicCamera",
    "title": "basicCamera",
    "content": "Standard camera equivalent to a traditional Camera COMP with default settings. ",
    "url": "/raytk/reference/operators/camera/basicCamera",
    "relUrl": "/reference/operators/camera/basicCamera"
  },"75": {
    "doc": "cameraRemap",
    "title": "cameraRemap",
    "content": "Modifies a camera by replacing the pixel UV coordinates that are used when calculating ray origins and directions. Insert this between a camera and a renderer. Typically the second input would be a dataTextureField that uses a TOP with a UV map. ",
    "url": "/raytk/reference/operators/camera/cameraRemap",
    "relUrl": "/reference/operators/camera/cameraRemap"
  },"76": {
    "doc": "fieldCamera",
    "title": "fieldCamera",
    "content": " ",
    "url": "/raytk/reference/operators/camera/fieldCamera",
    "relUrl": "/reference/operators/camera/fieldCamera"
  },"77": {
    "doc": "fisheyeCamera",
    "title": "fisheyeCamera",
    "content": "A 360 fisheye camera, that shows all directions from a specific point in space. ",
    "url": "/raytk/reference/operators/camera/fisheyeCamera",
    "relUrl": "/reference/operators/camera/fisheyeCamera"
  },"78": {
    "doc": "Camera Operators",
    "title": "Camera Operators",
    "content": "Operators that are used in raymarching to determine which direction rays should travel, effectively behaving as cameras. These operators are generally specialized for use in the raymarching CameraContext, and may not support being fed through filters or other OPs. ",
    "url": "/raytk/reference/operators/camera/",
    "relUrl": "/reference/operators/camera/"
  },"79": {
    "doc": "linkedCamera",
    "title": "linkedCamera",
    "content": "A camera that is linked to an existing TD Camera COMP. The camera will match the view of the TD camera, including local and world transformations, FOV settings, etc. It can be used to combine a raymarchRender3d with a traditional TD render TOP. ",
    "url": "/raytk/reference/operators/camera/linkedCamera",
    "relUrl": "/reference/operators/camera/linkedCamera"
  },"80": {
    "doc": "lookAtCamera",
    "title": "lookAtCamera",
    "content": "A camera that focuses on a specific point in space. ",
    "url": "/raytk/reference/operators/camera/lookAtCamera",
    "relUrl": "/reference/operators/camera/lookAtCamera"
  },"81": {
    "doc": "orthoCamera",
    "title": "orthoCamera",
    "content": "An orthographic (non-perspective) camera, which can be used for flattened front/side/etc views. ",
    "url": "/raytk/reference/operators/camera/orthoCamera",
    "relUrl": "/reference/operators/camera/orthoCamera"
  },"82": {
    "doc": "splitCamera",
    "title": "splitCamera",
    "content": "A camera that splits the viewport into several zones, each using a separate camera. Important note that when the horizontal and vertical layouts currently only use the first two inputs. ",
    "url": "/raytk/reference/operators/camera/splitCamera",
    "relUrl": "/reference/operators/camera/splitCamera"
  },"83": {
    "doc": "arrange",
    "title": "arrange",
    "content": "Combines multiple SDFs, with a different position for each. ",
    "url": "/raytk/reference/operators/combine/arrange",
    "relUrl": "/reference/operators/combine/arrange"
  },"84": {
    "doc": "boundLimit",
    "title": "boundLimit",
    "content": " ",
    "url": "/raytk/reference/operators/combine/boundLimit",
    "relUrl": "/reference/operators/combine/boundLimit"
  },"85": {
    "doc": "combine",
    "title": "combine",
    "content": "Combines SDFs in various ways. Depending on which Combine option is selected, different parameters will be enabled. This operator only supports two input SDFs (along with a value field to control blending). To combine more than two SDFs, use one of the specialized operators like simpleUnion. ",
    "url": "/raytk/reference/operators/combine/combine",
    "relUrl": "/reference/operators/combine/combine"
  },"86": {
    "doc": "combineFields",
    "title": "combineFields",
    "content": "Combines float or vector fields using one of several mathematical operations. ",
    "url": "/raytk/reference/operators/combine/combineFields",
    "relUrl": "/reference/operators/combine/combineFields"
  },"87": {
    "doc": "composeSdf",
    "title": "composeSdf",
    "content": "Combine multiple SDFs using different combination modes into a single SDF. This is essentially a replacement for long chains of combine operators. Once you’ve set up all the inputs and combine modes, switch on the Optimize setting which will compile down the generated code so that it runs much faster, but will make changes to settings much slower. ",
    "url": "/raytk/reference/operators/combine/composeSdf",
    "relUrl": "/reference/operators/combine/composeSdf"
  },"88": {
    "doc": "compositeFields",
    "title": "compositeFields",
    "content": "Combines two vector fields using color compositing. Based on Photoshop blending modes, using glsl-blend. The alpha channel is linearly blended between the two inputs using the Blend parameter. ",
    "url": "/raytk/reference/operators/combine/compositeFields",
    "relUrl": "/reference/operators/combine/compositeFields"
  },"89": {
    "doc": "edgeCombine",
    "title": "edgeCombine",
    "content": "Combines two SDFs in ways that use the intersection areas. ",
    "url": "/raytk/reference/operators/combine/edgeCombine",
    "relUrl": "/reference/operators/combine/edgeCombine"
  },"90": {
    "doc": "Combine Operators",
    "title": "Combine Operators",
    "content": "Operators that take two or more inputs and combine them into a single output. This includes operations that merge SDFs (union, diff, intersect), as well as more generic things like switches and cross-fade blending. ",
    "url": "/raytk/reference/operators/combine/",
    "relUrl": "/reference/operators/combine/"
  },"91": {
    "doc": "iterationSwitch",
    "title": "iterationSwitch",
    "content": "Switches between inputs based on the iteration value provided by a downstream operator. Only connected inputs are considered, and they are renumbered to skip over any missing ones. So if only 2 and 4 are connected, they are treated as 1 and 2. Iteration values are rounded to the nearest integer (after the Extend mode is applied to handle values outside the expected range from 0 to the number of connected inputs minus 1. ",
    "url": "/raytk/reference/operators/combine/iterationSwitch",
    "relUrl": "/reference/operators/combine/iterationSwitch"
  },"92": {
    "doc": "layoutGrid",
    "title": "layoutGrid",
    "content": "Slices space into a grid, and places each input in a separate cell. This is useful to see several different variations of a shape. The input shapes are shifted to the center of their cell. ",
    "url": "/raytk/reference/operators/combine/layoutGrid",
    "relUrl": "/reference/operators/combine/layoutGrid"
  },"93": {
    "doc": "mergeFields",
    "title": "mergeFields",
    "content": "Merges multiple vector fields, using different fields for each vector part. This is similar to the Reorder TOP. Each of the 4 vector parts (xyzw) has its own source setting specifying which input its value comes from. Inputs can either be float fields, or vector fields. If they are vector fields, then the corresponding part of that vector is used when creating the output. For example, if input 3 is a vector field, and Source Z is set to Input 3, the z in the result will be input1.z. ",
    "url": "/raytk/reference/operators/combine/mergeFields",
    "relUrl": "/reference/operators/combine/mergeFields"
  },"94": {
    "doc": "mixFields",
    "title": "mixFields",
    "content": " ",
    "url": "/raytk/reference/operators/combine/mixFields",
    "relUrl": "/reference/operators/combine/mixFields"
  },"95": {
    "doc": "shapedCombine",
    "title": "shapedCombine",
    "content": "Combine two SDFs, using a 2D SDF to shape the blending region. ",
    "url": "/raytk/reference/operators/combine/shapedCombine",
    "relUrl": "/reference/operators/combine/shapedCombine"
  },"96": {
    "doc": "simpleDiff",
    "title": "simpleDiff",
    "content": "Combines two SDFs using the difference operator. Produces the area of the first shape minus any areas overlapped by the second (or vice versa). ",
    "url": "/raytk/reference/operators/combine/simpleDiff",
    "relUrl": "/reference/operators/combine/simpleDiff"
  },"97": {
    "doc": "simpleIntersect",
    "title": "simpleIntersect",
    "content": "Combines SDFs using the intersect operator. Produces the areas where all input shapes overlap. ",
    "url": "/raytk/reference/operators/combine/simpleIntersect",
    "relUrl": "/reference/operators/combine/simpleIntersect"
  },"98": {
    "doc": "simpleUnion",
    "title": "simpleUnion",
    "content": "Combines several SDFs using the union operator. The resulting shape is the combined areas of all of the inputs. ",
    "url": "/raytk/reference/operators/combine/simpleUnion",
    "relUrl": "/reference/operators/combine/simpleUnion"
  },"99": {
    "doc": "switch",
    "title": "switch",
    "content": "Switches or blends between several inputs, without the need to rebuild the shader, allowing for fast switching. Note that inputs that are not connected are skipped over when assigning numbers to them, so if inputs 1, 2, and 4 are connected, they will use indices 0, 1, 2. ",
    "url": "/raytk/reference/operators/combine/switch",
    "relUrl": "/reference/operators/combine/switch"
  },"100": {
    "doc": "triPlanarCombine",
    "title": "triPlanarCombine",
    "content": "Combines three 2D fields based on vectors like surface normals. ",
    "url": "/raytk/reference/operators/combine/triPlanarCombine",
    "relUrl": "/reference/operators/combine/triPlanarCombine"
  },"101": {
    "doc": "coordTo2D",
    "title": "coordTo2D",
    "content": "Converts a 3D (or 1D) operator to work in a 2D plane on the chosen axes. ",
    "url": "/raytk/reference/operators/convert/coordTo2D",
    "relUrl": "/reference/operators/convert/coordTo2D"
  },"102": {
    "doc": "coordTo3D",
    "title": "coordTo3D",
    "content": "Converts a 2D (or 1D) operator to work in a 3D context. ",
    "url": "/raytk/reference/operators/convert/coordTo3D",
    "relUrl": "/reference/operators/convert/coordTo3D"
  },"103": {
    "doc": "crossSection",
    "title": "crossSection",
    "content": "Takes a 3D (or 2D) operator and take a cross section of it across a plane or a single axis. ",
    "url": "/raytk/reference/operators/convert/crossSection",
    "relUrl": "/reference/operators/convert/crossSection"
  },"104": {
    "doc": "extrude",
    "title": "extrude",
    "content": "Creates a 3D SDF by extruding a 2D SDF along along an axis. ",
    "url": "/raytk/reference/operators/convert/extrude",
    "relUrl": "/reference/operators/convert/extrude"
  },"105": {
    "doc": "extrudeLine",
    "title": "extrudeLine",
    "content": "Extrudes a 2D SDF cross-section into a 3D volume, like the extrude operator, but between two points. The extrude operator goes along a selected axis, with a height center on the origin. Instead of doing that, this operator extrudes so that one side is centered at Point1 and the other end at Point2. ",
    "url": "/raytk/reference/operators/convert/extrudeLine",
    "relUrl": "/reference/operators/convert/extrudeLine"
  },"106": {
    "doc": "floatToSdf",
    "title": "floatToSdf",
    "content": "Converts a float value field into an SDF. ",
    "url": "/raytk/reference/operators/convert/floatToSdf",
    "relUrl": "/reference/operators/convert/floatToSdf"
  },"107": {
    "doc": "floatToVector",
    "title": "floatToVector",
    "content": "Converts one or more float value field inputs into a single vector value field. ",
    "url": "/raytk/reference/operators/convert/floatToVector",
    "relUrl": "/reference/operators/convert/floatToVector"
  },"108": {
    "doc": "Convert Operators",
    "title": "Convert Operators",
    "content": "Operators that convert between different types of coordinates and return types (SDF, float/vector field, etc). ",
    "url": "/raytk/reference/operators/convert/",
    "relUrl": "/reference/operators/convert/"
  },"109": {
    "doc": "projectPlane",
    "title": "projectPlane",
    "content": "Takes a 1D or 2D operator and converts it to a 3D operator by mapping it to a plane within 3D space. This is a simplified version of coordTo3D. ",
    "url": "/raytk/reference/operators/convert/projectPlane",
    "relUrl": "/reference/operators/convert/projectPlane"
  },"110": {
    "doc": "projectPolar",
    "title": "projectPolar",
    "content": "Projects coordinates into various types of polar spaces. ",
    "url": "/raytk/reference/operators/convert/projectPolar",
    "relUrl": "/reference/operators/convert/projectPolar"
  },"111": {
    "doc": "revolve",
    "title": "revolve",
    "content": "Creates a 3D SDF by revolving a 2D cross-section SDF around an axis. ",
    "url": "/raytk/reference/operators/convert/revolve",
    "relUrl": "/reference/operators/convert/revolve"
  },"112": {
    "doc": "sampleAlongLine",
    "title": "sampleAlongLine",
    "content": "Samples a 2D/3D input along a single line, producing a 1D function. It’s similar to crossSection but with a single line instead of a 2D plane. ",
    "url": "/raytk/reference/operators/convert/sampleAlongLine",
    "relUrl": "/reference/operators/convert/sampleAlongLine"
  },"113": {
    "doc": "sweep",
    "title": "sweep",
    "content": "Creates a 3D SDF by sweeping a 2D SDF along the surface of another 2D SDF. ",
    "url": "/raytk/reference/operators/convert/sweep",
    "relUrl": "/reference/operators/convert/sweep"
  },"114": {
    "doc": "vectorToFloat",
    "title": "vectorToFloat",
    "content": "Converts a vector value field to a float field, e.g. using one part of the vector. ",
    "url": "/raytk/reference/operators/convert/vectorToFloat",
    "relUrl": "/reference/operators/convert/vectorToFloat"
  },"115": {
    "doc": "customOp",
    "title": "Shader Code",
    "content": "The Function code is the main block that defines the behavior of the op. It contains the definition of a function named thismap. This function must take two parameters: a coordinate named p, and a context value named ctx. The function returns some supported type of value. Type Aliases . Within shader code, CoordT, ContextT, and ReturnT are replaced with the actual types that the OP is using. This allows you to define an OP as using whatever kind of coordinates its input uses (e.g. vec2 or vec3) without having to change the code. ReturnT thismap(CoordT p, ContextT ctx) { // custom code goes here } . Prefixes and Uniqueness . Any functions, global variables, and macros defined in the shader code will be inserted into the generated shader. This means that they cannot conflict with things defined in any other OP or in the toolkit’s libraries. This can be a problem when copying and pasting code from Shadertoy or elsewhere. To avoid this, when defining any functions, global variables, or macros, use the prefix THIS_, which gets replaced with a unique op-specific prefix. float THIS_helperFunc(vec2 foo) { return foo.x * 12 + foo.y; } #define THIS_helperMacro 1.2345 float THIS_globalVar = 3; ReturnT thismap(CoordT p, ContextT ctx) { if (p.y &gt; THIS_globalVar) { THIS_globalVar = p.y; } return vec4(THIS_helperFunc(p.xy), THIS_helperMacro, THIS_globalVar, 0.); } . Using Inputs . ROPs connected to the inputs of the customOp are available to be called as functions named inputOp1, inputOp2, etc. When calling these, pass in some type of coordinate value and the ctx context value passed into the thismap function. ReturnT thismap(CoordT p, ContextT ctx) { return inputOp1(p.xz + vec2(THIS_Foo, 1.0), ctx); } . More Information About Shader Code . See Writing ROP Code for more details about ROP code. Note that some features described there may not be available for use with customOp. ",
    "url": "/raytk/reference/operators/custom/customOp#shader-code",
    "relUrl": "/reference/operators/custom/customOp#shader-code"
  },"116": {
    "doc": "customOp",
    "title": "Custom Parameters",
    "content": "In order to control the behavior of the op, you can create custom parameters on the associated “params” COMP which is created along with the customOp. These parameters can be used in the shader code as variables named like THIS_Paramname. The customOp’s “Tools” parameter page includes several pulse parameters that can help automatically manage these custom parameters based on the shader code. For example, ‘Createmissingparams’ will add new custom parameters that are referenced in the shader code but are missing on the “params” COMP. For multi-part parameters (Par styles including XYZ, RGBA, UV and Float/Int with more than 1 part) the alias evaluates to a value of the relevant vec* type, with the name of the tuplet without any suffix, which combines all of those parts (e.g. THIS_Translate). ",
    "url": "/raytk/reference/operators/custom/customOp#custom-parameters",
    "relUrl": "/reference/operators/custom/customOp#custom-parameters"
  },"117": {
    "doc": "customOp",
    "title": "customOp",
    "content": "A custom operator that integrates blocks of custom shader code into a RayTK network. When created, the operator will also create several docked operators that are used to provide define behavior. ",
    "url": "/raytk/reference/operators/custom/customOp",
    "relUrl": "/reference/operators/custom/customOp"
  },"118": {
    "doc": "Custom Operators",
    "title": "Custom Operators",
    "content": "Custom operators can be used to write custom GLSL code and run it in the context of a RayTK scene. ",
    "url": "/raytk/reference/operators/custom/",
    "relUrl": "/reference/operators/custom/"
  },"119": {
    "doc": "atmosphereField",
    "title": "atmosphereField",
    "content": "Field that simulates a sun and sky. This is primarily intended for use with the “Background Field” feature in raymarchRender3d. Example: . Based on glsl-atmosphere. ",
    "url": "/raytk/reference/operators/field/atmosphereField",
    "relUrl": "/reference/operators/field/atmosphereField"
  },"120": {
    "doc": "axisDistanceField",
    "title": "axisDistanceField",
    "content": "A float field that provides the distance from a specific point along a single axis. ",
    "url": "/raytk/reference/operators/field/axisDistanceField",
    "relUrl": "/reference/operators/field/axisDistanceField"
  },"121": {
    "doc": "bandField",
    "title": "bandField",
    "content": "Field that applies values based on a band/slice of an axis. For example, this can be used to have one color within Z = 0.3 to 0.5, and another color for all other coordinates. See also the slice operator, which behaves similarly for SDF results. ",
    "url": "/raytk/reference/operators/field/bandField",
    "relUrl": "/reference/operators/field/bandField"
  },"122": {
    "doc": "blackbodyColorField",
    "title": "blackbodyColorField",
    "content": "Field that produces colors using a model of blackbody radiation from physics. The operator uses a temperature value, either from a parameter of an input field, and determines the glow color that temperature would produce. Based on Tunnel Beauty by aiekick. Details on wikipedia. ",
    "url": "/raytk/reference/operators/field/blackbodyColorField",
    "relUrl": "/reference/operators/field/blackbodyColorField"
  },"123": {
    "doc": "cellTileField",
    "title": "cellTileField",
    "content": "A value field that provides an approximation of repeating cellular (voronoi) noise. Based on Biomine by Shane. Uses a minimum blend at various 3D locations on a cubic tile. Make the tile wrappable by ensuring the objects wrap around the edges. It isn’t perfect but it is low cost. ",
    "url": "/raytk/reference/operators/field/cellTileField",
    "relUrl": "/reference/operators/field/cellTileField"
  },"124": {
    "doc": "chopField",
    "title": "chopField",
    "content": "Field that provides values from a CHOP. ",
    "url": "/raytk/reference/operators/field/chopField",
    "relUrl": "/reference/operators/field/chopField"
  },"125": {
    "doc": "colorRampField",
    "title": "colorRampField",
    "content": "A vector field that maps an input field to values from a range of colors. ",
    "url": "/raytk/reference/operators/field/colorRampField",
    "relUrl": "/reference/operators/field/colorRampField"
  },"126": {
    "doc": "colorSwitchField",
    "title": "colorSwitchField",
    "content": "Switches or fades between a list of colors based on an index field. ",
    "url": "/raytk/reference/operators/field/colorSwitchField",
    "relUrl": "/reference/operators/field/colorSwitchField"
  },"127": {
    "doc": "constantColorField",
    "title": "constantColorField",
    "content": "A vector field that evaluates to a constant color value. This is the same as constantField, but the parameter is specified as a color instead of arbitrary float values. ",
    "url": "/raytk/reference/operators/field/constantColorField",
    "relUrl": "/reference/operators/field/constantColorField"
  },"128": {
    "doc": "constantField",
    "title": "constantField",
    "content": "A float or vector field that evaluates to a constant value. ",
    "url": "/raytk/reference/operators/field/constantField",
    "relUrl": "/reference/operators/field/constantField"
  },"129": {
    "doc": "constantSwitchField",
    "title": "constantSwitchField",
    "content": "Switches or blends between constant values based on an index field. ",
    "url": "/raytk/reference/operators/field/constantSwitchField",
    "relUrl": "/reference/operators/field/constantSwitchField"
  },"130": {
    "doc": "curlNoiseField",
    "title": "curlNoiseField",
    "content": "Curl noise field. Note that this operator can be very resource intensive, especially when used in a 3D raymarching scene. Based on https://github.com/cabbibo/glsl-curl-noise . ",
    "url": "/raytk/reference/operators/field/curlNoiseField",
    "relUrl": "/reference/operators/field/curlNoiseField"
  },"131": {
    "doc": "dataTextureField",
    "title": "dataTextureField",
    "content": "Accesses data from a texture with the same layout as the renderer. This is designed to be used with pointMapRender to load in precomputed data that follows the same pixel layout as the coordinate map, or with cameraRemap to use a UV map to change where each pixel’s ray starts. ",
    "url": "/raytk/reference/operators/field/dataTextureField",
    "relUrl": "/reference/operators/field/dataTextureField"
  },"132": {
    "doc": "domainColorField",
    "title": "domainColorField",
    "content": " ",
    "url": "/raytk/reference/operators/field/domainColorField",
    "relUrl": "/reference/operators/field/domainColorField"
  },"133": {
    "doc": "enhancedWaveField",
    "title": "enhancedWaveField",
    "content": "Field that produces different types of values based on wave functions. This is an enhanced version of the waveField operator with added convenience features, including: . | More wave functions including the pausingWaveFn, which is sort of like a square wave with ramped edges. | More control over the output value, including the ability to output vectors and colors. | Animation controls for the wave phase. | . ",
    "url": "/raytk/reference/operators/field/enhancedWaveField",
    "relUrl": "/reference/operators/field/enhancedWaveField"
  },"134": {
    "doc": "hashField",
    "title": "hashField",
    "content": "Advanced field that produces randomized values. This should typically be used with an input that provides numbers that the randomization should be based on, but it can be used without an input in which case it uses spatial position as the basis. A typical use case for this operator would be something like randomizing a property within each cell of a modulo2D. The cell coordinates, accessed using a variableReference, would be passed into the hashField, which would produce random numbers that could be mapped to control the radius of a cylinder for example. The available hash functions have different types of inputs and outputs. Some take a single number input and produce a single number. Others take a single number and produce vectors. And still others take in a vector with multiple parts to produce single numbers, etc. Each hash function has a different range of values that it will produce. Their labels in the parameter menu contain information about how they behave. The label suffixes are in the format (&lt;coord&gt; -&gt; &lt;return&gt;), where the first part is the type of coordinates or input value that it uses and the second is the type of value that it produces. Types labeled X mean it only uses/produces a single number, the X part of vectors. Types labeled XYZ mean it uses/produces 3 parts of vectors. Types marked with [U] mean unsigned integers, which treat all negative numbers as zero, and produce whole numbers ranging from 0 to 4294967295. Types without [U] mean floats, which can be any number. For outputs, that typically means a 0..1 or -1..1 range. Based on Hash Functions for GPU Rendering by markjarzynski. More details avaiable here. ",
    "url": "/raytk/reference/operators/field/hashField",
    "relUrl": "/reference/operators/field/hashField"
  },"135": {
    "doc": "hsvColorField",
    "title": "hsvColorField",
    "content": "A field that uses HSV-based parameters to produce colors. By default, the X axis is used for the hue. ",
    "url": "/raytk/reference/operators/field/hsvColorField",
    "relUrl": "/reference/operators/field/hsvColorField"
  },"136": {
    "doc": "Field Operators",
    "title": "Field Operators",
    "content": "Float or vector fields, which provide values for the requested coordinates. They can be used to control the behavior of other OPs, such as rotating by different amounts in different positions, or pulling color values from a texture. ",
    "url": "/raytk/reference/operators/field/",
    "relUrl": "/reference/operators/field/"
  },"137": {
    "doc": "iterationField",
    "title": "iterationField",
    "content": "Field that returns the current iteration, from a downstream OP. ",
    "url": "/raytk/reference/operators/field/iterationField",
    "relUrl": "/reference/operators/field/iterationField"
  },"138": {
    "doc": "magnetField",
    "title": "magnetField",
    "content": " ",
    "url": "/raytk/reference/operators/field/magnetField",
    "relUrl": "/reference/operators/field/magnetField"
  },"139": {
    "doc": "metaballField",
    "title": "metaballField",
    "content": "Metaball value field. ",
    "url": "/raytk/reference/operators/field/metaballField",
    "relUrl": "/reference/operators/field/metaballField"
  },"140": {
    "doc": "multiPointDistanceField",
    "title": "multiPointDistanceField",
    "content": "A vector field that provides the distance from 4 specific points in space (one for each part of the vector). ",
    "url": "/raytk/reference/operators/field/multiPointDistanceField",
    "relUrl": "/reference/operators/field/multiPointDistanceField"
  },"141": {
    "doc": "nearestRingPointField",
    "title": "nearestRingPointField",
    "content": " ",
    "url": "/raytk/reference/operators/field/nearestRingPointField",
    "relUrl": "/reference/operators/field/nearestRingPointField"
  },"142": {
    "doc": "noiseField",
    "title": "noiseField",
    "content": "A float or vector field that uses one of several noise functions. Some of these may be costly to compute, so pay attention to frame rate when using them. The different types of noise use different types of coordinates. If the type of coordinate used by Noisetype doesn’t match the Coordtype, any missing parts will be replaced with zeros. When the Coordtype is 3D but the Noisetype only uses 2D, the Axis parameter determines which parts of the coordinates are used. For types that use 4D coordinates, the Translate and Scale parameters can still be used to control the 4th coordinate. ",
    "url": "/raytk/reference/operators/field/noiseField",
    "relUrl": "/reference/operators/field/noiseField"
  },"143": {
    "doc": "normalField",
    "title": "normalField",
    "content": "Vector field that produces the surface normal where it is evaluated. This has been deprecated in favor of using the “Surface Normal” variable in material contexts. It can only be used in material or light contexts. ",
    "url": "/raytk/reference/operators/field/normalField",
    "relUrl": "/reference/operators/field/normalField"
  },"144": {
    "doc": "pointDistanceField",
    "title": "pointDistanceField",
    "content": "A float field that provides the distance from a specific point in space from either the current position or from another point. ",
    "url": "/raytk/reference/operators/field/pointDistanceField",
    "relUrl": "/reference/operators/field/pointDistanceField"
  },"145": {
    "doc": "polarCoordField",
    "title": "polarCoordField",
    "content": "A field that produces various types of polar coordinates. ",
    "url": "/raytk/reference/operators/field/polarCoordField",
    "relUrl": "/reference/operators/field/polarCoordField"
  },"146": {
    "doc": "polarVectorField",
    "title": "polarVectorField",
    "content": " ",
    "url": "/raytk/reference/operators/field/polarVectorField",
    "relUrl": "/reference/operators/field/polarVectorField"
  },"147": {
    "doc": "positionField",
    "title": "positionField",
    "content": "A vector field that produces the coordinates in space where it is checked. ",
    "url": "/raytk/reference/operators/field/positionField",
    "relUrl": "/reference/operators/field/positionField"
  },"148": {
    "doc": "rampField",
    "title": "rampField",
    "content": "Field that produces values that fade from one value to another along an axis or line. ",
    "url": "/raytk/reference/operators/field/rampField",
    "relUrl": "/reference/operators/field/rampField"
  },"149": {
    "doc": "rayField",
    "title": "rayField",
    "content": "Field that provides the ray direction or origin. When used in a material context, the ray is the one that went from the camera to the surface. When used in a background field, the ray is the one that went from the camera and missed all surfaces. ",
    "url": "/raytk/reference/operators/field/rayField",
    "relUrl": "/reference/operators/field/rayField"
  },"150": {
    "doc": "reorderField",
    "title": "reorderField",
    "content": " ",
    "url": "/raytk/reference/operators/field/reorderField",
    "relUrl": "/reference/operators/field/reorderField"
  },"151": {
    "doc": "sdfField",
    "title": "sdfField",
    "content": "Value field based on an SDF shape. This can be used to apply effects only within certain shaped areas of space. ",
    "url": "/raytk/reference/operators/field/sdfField",
    "relUrl": "/reference/operators/field/sdfField"
  },"152": {
    "doc": "sdfNormalField",
    "title": "sdfNormalField",
    "content": " ",
    "url": "/raytk/reference/operators/field/sdfNormalField",
    "relUrl": "/reference/operators/field/sdfNormalField"
  },"153": {
    "doc": "spectralColorField",
    "title": "spectralColorField",
    "content": "Produces colors using rainbow spectrum patterns. There are several spectrum types to choose from which balance the colors in different ways. The field will produce a color based on either the Wavelength parameter, or values from the wavelength input field. ",
    "url": "/raytk/reference/operators/field/spectralColorField",
    "relUrl": "/reference/operators/field/spectralColorField"
  },"154": {
    "doc": "stepField",
    "title": "stepField",
    "content": "A field that switches between two values at a threshold point. This can be used to apply one color to the left of some point and another color on the right side of that point. It can also smooth out the transition between the two values. ",
    "url": "/raytk/reference/operators/field/stepField",
    "relUrl": "/reference/operators/field/stepField"
  },"155": {
    "doc": "terrainNoiseField",
    "title": "terrainNoiseField",
    "content": "Noise that uses fBm (fractal brownian motion), which can work well for surface offsetting for terrain. Based on Musgrave’s Noises Collection by xbe. See also http://www.classes.cs.uchicago.edu/archive/2014/winter/23700-1/project_4_and_5/MusgraveTerrain00.pdf. ",
    "url": "/raytk/reference/operators/field/terrainNoiseField",
    "relUrl": "/reference/operators/field/terrainNoiseField"
  },"156": {
    "doc": "texture1dField",
    "title": "texture1dField",
    "content": " ",
    "url": "/raytk/reference/operators/field/texture1dField",
    "relUrl": "/reference/operators/field/texture1dField"
  },"157": {
    "doc": "texture3dField",
    "title": "texture3dField",
    "content": " ",
    "url": "/raytk/reference/operators/field/texture3dField",
    "relUrl": "/reference/operators/field/texture3dField"
  },"158": {
    "doc": "textureField",
    "title": "textureField",
    "content": "A float or vector field that looks up values from a texture. Texture is centered at 0,0 with coordinates from -0.5 to 0.5. ",
    "url": "/raytk/reference/operators/field/textureField",
    "relUrl": "/reference/operators/field/textureField"
  },"159": {
    "doc": "triPlanarTextureField",
    "title": "triPlanarTextureField",
    "content": "Texture field that uses surface normals (or other blending techniques) to apply a texture facing each axis. On a cube centered at the origin, this has the effect of placing the texture on each side of the cube. For a sphere, when using normal blending, the texture for each axis will smoothly blend as the surface normal shifts from one axis to another. Textures are centered at 0,0 with coordinates ranging from -0.5 to 0.5. ",
    "url": "/raytk/reference/operators/field/triPlanarTextureField",
    "relUrl": "/reference/operators/field/triPlanarTextureField"
  },"160": {
    "doc": "uvField",
    "title": "uvField",
    "content": "Field that produces surface UV coordinates, if available. This has been deprecated in favor of using the Surface UV variable in the material context. This can be used within modular materials for texture lookups. For surfaces that have assigned UV coordinates, the W part of the produced vector will be 1. For surfaces without UV coordinates, all parts of the vector will be 0. ",
    "url": "/raytk/reference/operators/field/uvField",
    "relUrl": "/reference/operators/field/uvField"
  },"161": {
    "doc": "waveField",
    "title": "waveField",
    "content": "A field that uses a periodic wave. If there is an input, that rop is used to get the coordinate that is fed into the wave function. Without an input, the Axis is used to run the wave function on the position along the selected axis. ",
    "url": "/raytk/reference/operators/field/waveField",
    "relUrl": "/reference/operators/field/waveField"
  },"162": {
    "doc": "waveVectorField",
    "title": "waveVectorField",
    "content": " ",
    "url": "/raytk/reference/operators/field/waveVectorField",
    "relUrl": "/reference/operators/field/waveVectorField"
  },"163": {
    "doc": "waveletNoiseField",
    "title": "waveletNoiseField",
    "content": " ",
    "url": "/raytk/reference/operators/field/waveletNoiseField",
    "relUrl": "/reference/operators/field/waveletNoiseField"
  },"164": {
    "doc": "worleyNoiseField",
    "title": "worleyNoiseField",
    "content": " ",
    "url": "/raytk/reference/operators/field/worleyNoiseField",
    "relUrl": "/reference/operators/field/worleyNoiseField"
  },"165": {
    "doc": "adjustColor",
    "title": "adjustColor",
    "content": "Adjust properties of color values, either directly on a field, or on the assigned surface color of an Sdf result. This is similar to Level TOP and HSV Adjust TOP. ",
    "url": "/raytk/reference/operators/filter/adjustColor",
    "relUrl": "/reference/operators/filter/adjustColor"
  },"166": {
    "doc": "applyTransform",
    "title": "applyTransform",
    "content": " ",
    "url": "/raytk/reference/operators/filter/applyTransform",
    "relUrl": "/reference/operators/filter/applyTransform"
  },"167": {
    "doc": "assignAttribute",
    "title": "assignAttribute",
    "content": " ",
    "url": "/raytk/reference/operators/filter/assignAttribute",
    "relUrl": "/reference/operators/filter/assignAttribute"
  },"168": {
    "doc": "assignColor",
    "title": "assignColor",
    "content": "Assigns a surface color attribute to an SDF surface. Various types of materials and fields can access and use the surface color attributes. ",
    "url": "/raytk/reference/operators/filter/assignColor",
    "relUrl": "/reference/operators/filter/assignColor"
  },"169": {
    "doc": "assignDensity",
    "title": "assignDensity",
    "content": " ",
    "url": "/raytk/reference/operators/filter/assignDensity",
    "relUrl": "/reference/operators/filter/assignDensity"
  },"170": {
    "doc": "assignUV",
    "title": "assignUV",
    "content": "Assigns UV coordinates to an SDF surface. Coordinates can either be determined using the selected UV Mode, or using a vector field input. ",
    "url": "/raytk/reference/operators/filter/assignUV",
    "relUrl": "/reference/operators/filter/assignUV"
  },"171": {
    "doc": "axisRotate",
    "title": "axisRotate",
    "content": "A simplified and optimized version of rotate, which only supports rotating around a single axis (x, y, or z). In many cases this will be more efficient than rotate. ",
    "url": "/raytk/reference/operators/filter/axisRotate",
    "relUrl": "/reference/operators/filter/axisRotate"
  },"172": {
    "doc": "bend",
    "title": "bend",
    "content": "Bends space, along a main axis, towards a second axis. For example, bends sideways (towards X) depending on the vertical position (along Y). ",
    "url": "/raytk/reference/operators/filter/bend",
    "relUrl": "/reference/operators/filter/bend"
  },"173": {
    "doc": "cameraTransform",
    "title": "cameraTransform",
    "content": "Specialized transform that can be applied to cameras. Similar to lightTransform, this operator is designed to work specifically with cameras, including changes to direction and look at position. ",
    "url": "/raytk/reference/operators/filter/cameraTransform",
    "relUrl": "/reference/operators/filter/cameraTransform"
  },"174": {
    "doc": "cartesianToPolar",
    "title": "cartesianToPolar",
    "content": "Convert from cartesian space to various types of polar spaces. ",
    "url": "/raytk/reference/operators/filter/cartesianToPolar",
    "relUrl": "/reference/operators/filter/cartesianToPolar"
  },"175": {
    "doc": "circularRepeat",
    "title": "circularRepeat",
    "content": "Repeat an space to fill a 2D circular area. ",
    "url": "/raytk/reference/operators/filter/circularRepeat",
    "relUrl": "/reference/operators/filter/circularRepeat"
  },"176": {
    "doc": "elongate",
    "title": "elongate",
    "content": "Stretches a shape by splitting it into pieces, moves them apart, and connects them. For example, a capsule is an elongated version of a sphere. It is based on code from Inigo Quilez. See example. ",
    "url": "/raytk/reference/operators/filter/elongate",
    "relUrl": "/reference/operators/filter/elongate"
  },"177": {
    "doc": "extend",
    "title": "extend",
    "content": "Clamps coordinates around an area, which causes its edges to be extended infinitely along each axis. ",
    "url": "/raytk/reference/operators/filter/extend",
    "relUrl": "/reference/operators/filter/extend"
  },"178": {
    "doc": "fieldExpr",
    "title": "fieldExpr",
    "content": "Modifies field values using a custom expression. The Expression parameter’s menu contains common examples. Writing expressions: . | To access a value from input 1, use a function call like inputOp1(p, ctx) . | The p part is the spatial coordinate, so you can modify it with something like inputOp1(p + vec3(1, 0, 0), ctx), which would move that field to the left. | The ctx part is required as the second argument to the function. | . | Other inputs are available as inputOp2(...) etc | The two slider parameters are available as THIS_Param1 and THIS_Param2 | The two vector parameters are available as THIS_Vecparam1 and THIS_Vecparam2 . | To get at an individual part of one of the vector params, you can use THIS_Vecparam1.y | . | . ",
    "url": "/raytk/reference/operators/filter/fieldExpr",
    "relUrl": "/reference/operators/filter/fieldExpr"
  },"179": {
    "doc": "fieldFunction",
    "title": "fieldFunction",
    "content": "Modifies the values of a field using various types of math functions, similar to a Function CHOP. ",
    "url": "/raytk/reference/operators/filter/fieldFunction",
    "relUrl": "/reference/operators/filter/fieldFunction"
  },"180": {
    "doc": "flip",
    "title": "flip",
    "content": "Flips the input across an axis, either on its own or merged with the original. ",
    "url": "/raytk/reference/operators/filter/flip",
    "relUrl": "/reference/operators/filter/flip"
  },"181": {
    "doc": "fold",
    "title": "fold",
    "content": " ",
    "url": "/raytk/reference/operators/filter/fold",
    "relUrl": "/reference/operators/filter/fold"
  },"182": {
    "doc": "geometricSeriesSquareTile",
    "title": "geometricSeriesSquareTile",
    "content": "Repeats space in a square arrangement that gets smaller in the center. ",
    "url": "/raytk/reference/operators/filter/geometricSeriesSquareTile",
    "relUrl": "/reference/operators/filter/geometricSeriesSquareTile"
  },"183": {
    "doc": "gridClone",
    "title": "gridClone",
    "content": "Repeats an SDF in a grid arrangement, combining the results. It’s important to remember that this operator performs the work of its input once for each clone. That means that a 3x3 grid does 27 times the work of the input. The modulo3D (or modulo1D/modulo2D) can be a cheaper alternative to gridClone with some limitations. ",
    "url": "/raytk/reference/operators/filter/gridClone",
    "relUrl": "/reference/operators/filter/gridClone"
  },"184": {
    "doc": "helixWarp",
    "title": "helixWarp",
    "content": "Warps space in a helix pattern around an axis. This operator pushes space along two axes by varying amounts along the third axis. When applied to a cylinder along that main axis, this would produce a helix shape. Note that it doesn’t actually do any rotation, just shifts it side to side (and front to back, if using the Y axis). ",
    "url": "/raytk/reference/operators/filter/helixWarp",
    "relUrl": "/reference/operators/filter/helixWarp"
  },"185": {
    "doc": "hilbertCurveTransform",
    "title": "hilbertCurveTransform",
    "content": " ",
    "url": "/raytk/reference/operators/filter/hilbertCurveTransform",
    "relUrl": "/reference/operators/filter/hilbertCurveTransform"
  },"186": {
    "doc": "Filter Operators",
    "title": "Filter Operators",
    "content": "Operators that take an input and modify it. Many of these are spatial transformations (scale, rotate, translate), which alter the coordinates that are used by their input operator. Many of these can be used for various types of return types (SDFs, float/vector fields, etc). Some only support a limited set of return types. ",
    "url": "/raytk/reference/operators/filter/",
    "relUrl": "/reference/operators/filter/"
  },"187": {
    "doc": "instance",
    "title": "instance",
    "content": "Repeats its input some number of times, exposing the index as the iteration x value, and combines the results. It is important to note that unless something in the input chain is making use of the iteration to change or move those copies, they will all be in the same position. The rangeTransform operator is designed for this purpose, though there are also other ops that can do so. Refer to the Iteration guide for details. It is also important to note that this operator, like radialClone evaluates its input separately for each iteration, which can cause a significant drain on resources if the input network is complex or costly. ",
    "url": "/raytk/reference/operators/filter/instance",
    "relUrl": "/reference/operators/filter/instance"
  },"188": {
    "doc": "instanceField",
    "title": "instanceField",
    "content": "Repeats an input field multiple times and combines the results. Note that this multiplies the work of the input once per instance. ",
    "url": "/raytk/reference/operators/filter/instanceField",
    "relUrl": "/reference/operators/filter/instanceField"
  },"189": {
    "doc": "invert",
    "title": "invert",
    "content": "Invert an SDF, so that the inside is the outside. If used on a box, this can create an empty room with the shape filling all the space outside the room. ",
    "url": "/raytk/reference/operators/filter/invert",
    "relUrl": "/reference/operators/filter/invert"
  },"190": {
    "doc": "iteratedTransform",
    "title": "iteratedTransform",
    "content": "Performs a transform multiple times, optionally reflecting across axes in between the steps. This can be used to create KIFS fractals (kaleidoscopic iterated function systems). ",
    "url": "/raytk/reference/operators/filter/iteratedTransform",
    "relUrl": "/reference/operators/filter/iteratedTransform"
  },"191": {
    "doc": "kink",
    "title": "kink",
    "content": "Bends space, similar to the bend. The bending that this operator applies is slightly different than the bend operator, and is asymmetrical, causing a tighter bend on one side based on the bend amount and direction. Based on Bending an SDF by blackle. ",
    "url": "/raytk/reference/operators/filter/kink",
    "relUrl": "/reference/operators/filter/kink"
  },"192": {
    "doc": "knife",
    "title": "knife",
    "content": "Cuts off an SDF along a plane. ",
    "url": "/raytk/reference/operators/filter/knife",
    "relUrl": "/reference/operators/filter/knife"
  },"193": {
    "doc": "lightTransform",
    "title": "lightTransform",
    "content": "Specialized transform that can be applied to lights, taking into account things like look at direction. Similar to cameraTransform, this operator is specificaly designed to work on lights. ",
    "url": "/raytk/reference/operators/filter/lightTransform",
    "relUrl": "/reference/operators/filter/lightTransform"
  },"194": {
    "doc": "limitArea",
    "title": "limitArea",
    "content": "Use an SDF to limit the area where a field produces values. Within the specified bounds, the value from the first input field is used. Outside the bounds, if there’s a second input field, that is used instead. Otherwise the Outside Value parameter is used for those areas. ",
    "url": "/raytk/reference/operators/filter/limitArea",
    "relUrl": "/reference/operators/filter/limitArea"
  },"195": {
    "doc": "limitField",
    "title": "limitField",
    "content": "Limits the values produced by a float or vector field. This is similar to the Limit CHOP. ",
    "url": "/raytk/reference/operators/filter/limitField",
    "relUrl": "/reference/operators/filter/limitField"
  },"196": {
    "doc": "limitLight",
    "title": "limitLight",
    "content": "Limits the brightness of a light using distance attenuation or a bounding SDF (or both). Attenuation makes the light full brightness at the position of the light and after a distance it tapers off to darkness. Bounding SDFs do something similar but instead of using distance from the light source, they use an SDF that defines an area within which the light is at full brightness. The optimization feature tells the renderer that in places where attentuation / bounding says the light should be totally off, the renderer can skip attempting to use that light at all for any materials there. ",
    "url": "/raytk/reference/operators/filter/limitLight",
    "relUrl": "/reference/operators/filter/limitLight"
  },"197": {
    "doc": "linearClone",
    "title": "linearClone",
    "content": "Repeats an SDF along a line, combining the results. Note that this multiplies the work of the input for each clone, meaning that 4 clones means 4x the work of whatever is connected to the input. The modulo1D can be a cheaper alternative to linearClone though it comes with limitations. ",
    "url": "/raytk/reference/operators/filter/linearClone",
    "relUrl": "/reference/operators/filter/linearClone"
  },"198": {
    "doc": "logPolarRepeat",
    "title": "logPolarRepeat",
    "content": " ",
    "url": "/raytk/reference/operators/filter/logPolarRepeat",
    "relUrl": "/reference/operators/filter/logPolarRepeat"
  },"199": {
    "doc": "lookAtRotate",
    "title": "lookAtRotate",
    "content": "Rotates space to face towards a point. ",
    "url": "/raytk/reference/operators/filter/lookAtRotate",
    "relUrl": "/reference/operators/filter/lookAtRotate"
  },"200": {
    "doc": "magnet",
    "title": "magnet",
    "content": "Pulls or twists space within an area. If the magnet definition input is connected, that operator is used to determine how much transformation to apply at each point in space. If there is no magnet definition connected, the magnet is based around a center point with a radius, and a blending region. ",
    "url": "/raytk/reference/operators/filter/magnet",
    "relUrl": "/reference/operators/filter/magnet"
  },"201": {
    "doc": "mirrorAxes",
    "title": "mirrorAxes",
    "content": "Mirror space across one or more axes, similar to reflect. ",
    "url": "/raytk/reference/operators/filter/mirrorAxes",
    "relUrl": "/reference/operators/filter/mirrorAxes"
  },"202": {
    "doc": "mirrorOctant",
    "title": "mirrorOctant",
    "content": "Mirror coordinates across two axes and the diagonals. ",
    "url": "/raytk/reference/operators/filter/mirrorOctant",
    "relUrl": "/reference/operators/filter/mirrorOctant"
  },"203": {
    "doc": "mirrorQuadrant",
    "title": "mirrorQuadrant",
    "content": "Mirror coordinates across two axes. This is similar to mirrorOctant but without mirroring on the diagonals. ",
    "url": "/raytk/reference/operators/filter/mirrorQuadrant",
    "relUrl": "/reference/operators/filter/mirrorQuadrant"
  },"204": {
    "doc": "mobiusTransform",
    "title": "mobiusTransform",
    "content": " ",
    "url": "/raytk/reference/operators/filter/mobiusTransform",
    "relUrl": "/reference/operators/filter/mobiusTransform"
  },"205": {
    "doc": "modifyDistance",
    "title": "modifyDistance",
    "content": " ",
    "url": "/raytk/reference/operators/filter/modifyDistance",
    "relUrl": "/reference/operators/filter/modifyDistance"
  },"206": {
    "doc": "modifyNormals",
    "title": "modifyNormals",
    "content": "Use a field to modify the normals (bump mapping) used by shading elements in a modular material. This must be used within the modular material network, rather than on an SDF that uses such a material. In other words, insert it between an operator like diffuseContrib and the modularMat. This can be combined with a noiseField or textureField to apply bump mapping to a surface. ",
    "url": "/raytk/reference/operators/filter/modifyNormals",
    "relUrl": "/reference/operators/filter/modifyNormals"
  },"207": {
    "doc": "modulo1D",
    "title": "modulo1D",
    "content": "Repeats space along one axis. This has the effect of making infinite copies of (slices of) the input, but without the cost of having to separately calculate each copy. ",
    "url": "/raytk/reference/operators/filter/modulo1D",
    "relUrl": "/reference/operators/filter/modulo1D"
  },"208": {
    "doc": "modulo2D",
    "title": "modulo2D",
    "content": "Repeats space along 2 axes. This has the effect of making an infinite grid of copies of (slices/cells of) the input, but without the cost of having to separately calculate each copy. ",
    "url": "/raytk/reference/operators/filter/modulo2D",
    "relUrl": "/reference/operators/filter/modulo2D"
  },"209": {
    "doc": "modulo3D",
    "title": "modulo3D",
    "content": "Repeats space along all 3 axes. This has the effect of making an infinite 3D grid of copies of (slices/cells of) the input, but without the cost of having to separately calculate each one. ",
    "url": "/raytk/reference/operators/filter/modulo3D",
    "relUrl": "/reference/operators/filter/modulo3D"
  },"210": {
    "doc": "moduloDistance",
    "title": "moduloDistance",
    "content": " ",
    "url": "/raytk/reference/operators/filter/moduloDistance",
    "relUrl": "/reference/operators/filter/moduloDistance"
  },"211": {
    "doc": "moduloLine",
    "title": "moduloLine",
    "content": "Repeats space along a line, similar to modulo1D. Similar to modulo1D, this operator repeats space in a row of slices. But instead of being on an axis, it uses an arbitrary line defined by two points, with a fixed number of evenly spaced slices between them. ",
    "url": "/raytk/reference/operators/filter/moduloLine",
    "relUrl": "/reference/operators/filter/moduloLine"
  },"212": {
    "doc": "moduloPolar",
    "title": "moduloPolar",
    "content": "Repeats space radially, like a kaleidoscope. ",
    "url": "/raytk/reference/operators/filter/moduloPolar",
    "relUrl": "/reference/operators/filter/moduloPolar"
  },"213": {
    "doc": "moduloSpherical",
    "title": "moduloSpherical",
    "content": "Repeats space in a spherical mesh layout with rows and columns. ",
    "url": "/raytk/reference/operators/filter/moduloSpherical",
    "relUrl": "/reference/operators/filter/moduloSpherical"
  },"214": {
    "doc": "moduloToroidal",
    "title": "moduloToroidal",
    "content": "Repeats space as rows and columns of a torus-shaped grid. ",
    "url": "/raytk/reference/operators/filter/moduloToroidal",
    "relUrl": "/reference/operators/filter/moduloToroidal"
  },"215": {
    "doc": "onion",
    "title": "onion",
    "content": "Converts a solid SDF to a thin shell of the surface. The shell is created centered on the surface, with half of the Thickness going toward the outside and the other half on the inside. This has the effect of increasing the size of the outside of the shape. Without somehow slicing through the shell, using things like knife or slice, you generally won’t be able to tell the difference between this and round, in that it will seem to just increase the size of the shape. See https://www.shadertoy.com/view/MlcBDj . ",
    "url": "/raytk/reference/operators/filter/onion",
    "relUrl": "/reference/operators/filter/onion"
  },"216": {
    "doc": "polarToCartesian",
    "title": "polarToCartesian",
    "content": "Converts coordinates from polar to cartesian. ",
    "url": "/raytk/reference/operators/filter/polarToCartesian",
    "relUrl": "/reference/operators/filter/polarToCartesian"
  },"217": {
    "doc": "quadTreeRepeat",
    "title": "quadTreeRepeat",
    "content": "Repeats space in a 2d grid where some cells are subdivided into smaller cells recursively. ",
    "url": "/raytk/reference/operators/filter/quadTreeRepeat",
    "relUrl": "/reference/operators/filter/quadTreeRepeat"
  },"218": {
    "doc": "quantizeCoords",
    "title": "quantizeCoords",
    "content": "Quantize coordinates to a 3D grid, which is sort of like “voxelizing” the space. ",
    "url": "/raytk/reference/operators/filter/quantizeCoords",
    "relUrl": "/reference/operators/filter/quantizeCoords"
  },"219": {
    "doc": "quantizeValue",
    "title": "quantizeValue",
    "content": " ",
    "url": "/raytk/reference/operators/filter/quantizeValue",
    "relUrl": "/reference/operators/filter/quantizeValue"
  },"220": {
    "doc": "radialClone",
    "title": "radialClone",
    "content": "Repeats an SDF radially around an axis, combining the resulting shapes. Note that this runs its input multiple times, which can lead to performance issues. ",
    "url": "/raytk/reference/operators/filter/radialClone",
    "relUrl": "/reference/operators/filter/radialClone"
  },"221": {
    "doc": "radialSlice",
    "title": "radialSlice",
    "content": "Takes a pie-shaped slice of an SDF around an axis, either removing it or everything except it. ",
    "url": "/raytk/reference/operators/filter/radialSlice",
    "relUrl": "/reference/operators/filter/radialSlice"
  },"222": {
    "doc": "rangeTransform",
    "title": "rangeTransform",
    "content": "Applies a transform based on a range of settings, mapped with either the iteration value or a field input. This operator defines two different sets of transform settings. It then uses some index value to decide where in that range it will use. A simple use case for this would be iteration with 3 items, where the first item moves to one position and the last item moves to another position, and the one in the middle moves to half way between those two. The index is based either on the first (x) part of the iteration value provided by a downstream op, or if the second input is connected, that float value field is used to determine the index. The index is then scaled from the specified range down to 0..1. The Extend parameter controls how values outside that range are handled. ",
    "url": "/raytk/reference/operators/filter/rangeTransform",
    "relUrl": "/reference/operators/filter/rangeTransform"
  },"223": {
    "doc": "rectangleRepeat",
    "title": "rectangleRepeat",
    "content": " ",
    "url": "/raytk/reference/operators/filter/rectangleRepeat",
    "relUrl": "/reference/operators/filter/rectangleRepeat"
  },"224": {
    "doc": "reflect",
    "title": "reflect",
    "content": "Reflects space across a plane. ",
    "url": "/raytk/reference/operators/filter/reflect",
    "relUrl": "/reference/operators/filter/reflect"
  },"225": {
    "doc": "remapCoords",
    "title": "remapCoords",
    "content": "Modifies space using a vector field. When the shader uses the operator, it will first pass the coordinates to the “Coord Field”. It then uses the resulting remapped coordinates when running the first input operator. ",
    "url": "/raytk/reference/operators/filter/remapCoords",
    "relUrl": "/reference/operators/filter/remapCoords"
  },"226": {
    "doc": "reorderCoords",
    "title": "reorderCoords",
    "content": "Swaps axes for the input. ",
    "url": "/raytk/reference/operators/filter/reorderCoords",
    "relUrl": "/reference/operators/filter/reorderCoords"
  },"227": {
    "doc": "rescaleField",
    "title": "rescaleField",
    "content": "Rescales the values produced by a field. This is equivalent to the “Range” parameters in a Math CHOP. It works for either float value fields or vector fields. When using a float value field, only the first part of each of the range parameters is used. ",
    "url": "/raytk/reference/operators/filter/rescaleField",
    "relUrl": "/reference/operators/filter/rescaleField"
  },"228": {
    "doc": "rescaleFloatField",
    "title": "rescaleFloatField",
    "content": "Simplified version of rescaleField that only has single settings vs vectors for each. This can be applied to either float or vector fields. In the case of vector fields, the same settings are used for all parts of the incoming vectors. ",
    "url": "/raytk/reference/operators/filter/rescaleFloatField",
    "relUrl": "/reference/operators/filter/rescaleFloatField"
  },"229": {
    "doc": "reshapeValues",
    "title": "reshapeValues",
    "content": "Reshapes the values produced by a field by applying a function. If the source field produces float values, the function is just applied to those values, returning whatever type the function returns. If the source field produces vector values, the function is applied individually to each channel in the produced values. If the source is an SDF, the function is applied to the distance value in the SDF result. ",
    "url": "/raytk/reference/operators/filter/reshapeValues",
    "relUrl": "/reference/operators/filter/reshapeValues"
  },"230": {
    "doc": "restrictStage",
    "title": "restrictStage",
    "content": "Restricts which render stages an operator is used in. This can be used for optimization, by switching off expensive ROPs for shadows. It can also be used to have shapes that are invisible but still cast shadows. In cases where the main operator is not being included, this will produce either the alternative operator input (if connected), or a default value otherwise. The default value is “non-hit” for SDFs, and 0 / vec4(0) etc for other types. ",
    "url": "/raytk/reference/operators/filter/restrictStage",
    "relUrl": "/reference/operators/filter/restrictStage"
  },"231": {
    "doc": "rotate",
    "title": "rotate",
    "content": "Transforms space with rotation. The operator has 2 main modes: a single rotation around an axis, or 3 separate rotations around each axis. ",
    "url": "/raytk/reference/operators/filter/rotate",
    "relUrl": "/reference/operators/filter/rotate"
  },"232": {
    "doc": "rotate4D",
    "title": "rotate4D",
    "content": "Projects 3D space into 4D space, applies rotation along two axes and then projects back into 3D space. ",
    "url": "/raytk/reference/operators/filter/rotate4D",
    "relUrl": "/reference/operators/filter/rotate4D"
  },"233": {
    "doc": "rotateNormals",
    "title": "rotateNormals",
    "content": "Applies rotation to the surface normals used by material elements such as specularContrib. ",
    "url": "/raytk/reference/operators/filter/rotateNormals",
    "relUrl": "/reference/operators/filter/rotateNormals"
  },"234": {
    "doc": "round",
    "title": "round",
    "content": "Adds to (or subtracts from) the size of an SDF, which has the effect of rounding it out or shrinking it. Based on code from Inigo Quilez. See example. ",
    "url": "/raytk/reference/operators/filter/round",
    "relUrl": "/reference/operators/filter/round"
  },"235": {
    "doc": "scale",
    "title": "scale",
    "content": "Scales space. Scaling works for either 3D or 2D inputs. ",
    "url": "/raytk/reference/operators/filter/scale",
    "relUrl": "/reference/operators/filter/scale"
  },"236": {
    "doc": "slice",
    "title": "slice",
    "content": "Takes a slice of an SDF along an axis, either removing it or everything except it. ",
    "url": "/raytk/reference/operators/filter/slice",
    "relUrl": "/reference/operators/filter/slice"
  },"237": {
    "doc": "sphericalMobiusTransform",
    "title": "sphericalMobiusTransform",
    "content": " ",
    "url": "/raytk/reference/operators/filter/sphericalMobiusTransform",
    "relUrl": "/reference/operators/filter/sphericalMobiusTransform"
  },"238": {
    "doc": "spin",
    "title": "spin",
    "content": "Rotation on XYZ with built-in animation. ",
    "url": "/raytk/reference/operators/filter/spin",
    "relUrl": "/reference/operators/filter/spin"
  },"239": {
    "doc": "spiralZoom",
    "title": "spiralZoom",
    "content": "Transforms space using a logarithmic spiral. See this article for a good description of the concept: https://isohedral.ca/escher-like-spiral-tilings/ . In a sense, this has some similar properties to modulo2D in that it takes a slice of space and repeats it. But instead of repeating it linearly along the x and y axes, it does so with polar coordinates (angle and distance). Important note: if the input pattern / shape does not tile correctly for the slice that’s used, you will get a discontinuity (break in space). This is similar to how you shapes can get cut off when using modulo1D / etc. When using 2D coordinates, the Axis is ignored, and the first axis is always X and the second is always Y. ",
    "url": "/raytk/reference/operators/filter/spiralZoom",
    "relUrl": "/reference/operators/filter/spiralZoom"
  },"240": {
    "doc": "transform",
    "title": "transform",
    "content": "Transform the coordinates of the input, with rotation, scaling, and translation. Various parts of the transform can be switched off to improve performance, and the sequence of transform steps can be reordered. It either uses the origin (0,0,0) as the pivot point, or can use another pivot point. ",
    "url": "/raytk/reference/operators/filter/transform",
    "relUrl": "/reference/operators/filter/transform"
  },"241": {
    "doc": "transformSequence",
    "title": "transformSequence",
    "content": "Applies one or more transform operators sequentially, to coordinates, field values, etc, with support for looping. The first input is the primary input, which can either be an arbitrary operator which will get the transformed coordinates, or it can be a field whose values are transformed, or an SDF whose UV coordinates are transformed, etc. The second and later inputs are the sequence of transforms that are applied to the primary. The second input gets the coordinates/values to be transformed, and the vector that it produces gets passed into the next input, and so on. The output of the last connected input is used as the final value/coordinates. Many transform filters support a mode where they have no attached primary input, in which case they act as fields producing their coordinates as a vector. But for transform filters that require a primary input, a positionField can be attached to do the same thing. The looping feature allows this operator to behave like a custom-built version of iteratedTransform, repeating the sequence of transformations multiple times. ",
    "url": "/raytk/reference/operators/filter/transformSequence",
    "relUrl": "/reference/operators/filter/transformSequence"
  },"242": {
    "doc": "translate",
    "title": "translate",
    "content": "Translates coordinates of the input ROP. Translate can be used in 2D or 3D. It can either specify an offset for each axis, or a direction and a distance. When specifying an offset for each axis, it can optionally use a vector field to apply variable amounts of translation based on coordinates. If a field is used, the field values are added to the Translate XYZ parameter. When specifying a direction and distance, it can optionally use a field to add to the distance specified in the Distance parameter. ",
    "url": "/raytk/reference/operators/filter/translate",
    "relUrl": "/reference/operators/filter/translate"
  },"243": {
    "doc": "twirl",
    "title": "twirl",
    "content": " ",
    "url": "/raytk/reference/operators/filter/twirl",
    "relUrl": "/reference/operators/filter/twirl"
  },"244": {
    "doc": "twist",
    "title": "twist",
    "content": "Twists space around an axis. ",
    "url": "/raytk/reference/operators/filter/twist",
    "relUrl": "/reference/operators/filter/twist"
  },"245": {
    "doc": "uvTransform",
    "title": "uvTransform",
    "content": "Transform the UV coordinates assigned to an SDF result. ",
    "url": "/raytk/reference/operators/filter/uvTransform",
    "relUrl": "/reference/operators/filter/uvTransform"
  },"246": {
    "doc": "waveWarp",
    "title": "waveWarp",
    "content": "Uses repeating waves to offset space. The Axis parameter determines which axis is used to produce the waves. A separate wave is used for offsetting for each axis. The Period and Phase parameters control the spacing and position of the waves. The Amplitude and Offset parameters control how much each axis’s wave shifts coordinates on that axis. ",
    "url": "/raytk/reference/operators/filter/waveWarp",
    "relUrl": "/reference/operators/filter/waveWarp"
  },"247": {
    "doc": "addFn",
    "title": "addFn",
    "content": "Adds the returned values produced by all of the connected input functions. ",
    "url": "/raytk/reference/operators/function/addFn",
    "relUrl": "/reference/operators/function/addFn"
  },"248": {
    "doc": "almostIdentityFn",
    "title": "almostIdentityFn",
    "content": "A mapping function that can change a value only when it’s zero or very close to it, where it replaces the value with a small constant. Then, rather than doing a conditional branch which introduces a discontinuity, you can smoothly blend your value with your Threshold. This is based on Inigo Quilez’s article. ",
    "url": "/raytk/reference/operators/function/almostIdentityFn",
    "relUrl": "/reference/operators/function/almostIdentityFn"
  },"249": {
    "doc": "chopFn",
    "title": "chopFn",
    "content": "Function that looks up values in a CHOP. ",
    "url": "/raytk/reference/operators/function/chopFn",
    "relUrl": "/reference/operators/function/chopFn"
  },"250": {
    "doc": "colorPaletteFn",
    "title": "colorPaletteFn",
    "content": " ",
    "url": "/raytk/reference/operators/function/colorPaletteFn",
    "relUrl": "/reference/operators/function/colorPaletteFn"
  },"251": {
    "doc": "crossFn",
    "title": "crossFn",
    "content": "Cross-fades between two input functions, either based on a parameter or on a third function. A mix value of 0 is the first, 1 is the second. Values outside that range will linearly scale, as though the two input values are two points and a line extends off in the same direction on each end. ",
    "url": "/raytk/reference/operators/function/crossFn",
    "relUrl": "/reference/operators/function/crossFn"
  },"252": {
    "doc": "cubicPulseFn",
    "title": "cubicPulseFn",
    "content": " ",
    "url": "/raytk/reference/operators/function/cubicPulseFn",
    "relUrl": "/reference/operators/function/cubicPulseFn"
  },"253": {
    "doc": "easeFn",
    "title": "easeFn",
    "content": " ",
    "url": "/raytk/reference/operators/function/easeFn",
    "relUrl": "/reference/operators/function/easeFn"
  },"254": {
    "doc": "extendFn",
    "title": "extendFn",
    "content": "Defines the behavior of a function outside the normal expected range of coordinates. This is similar to the Extend CHOP. While primarily useful for 1D function operators, it also works for 2D and 3D operators, by applying the extend mode to each part of the coordinates. ",
    "url": "/raytk/reference/operators/function/extendFn",
    "relUrl": "/reference/operators/function/extendFn"
  },"255": {
    "doc": "flipFn",
    "title": "flipFn",
    "content": "Function that flips its input in one of several different modes. ",
    "url": "/raytk/reference/operators/function/flipFn",
    "relUrl": "/reference/operators/function/flipFn"
  },"256": {
    "doc": "gainFn",
    "title": "gainFn",
    "content": "A function that expands the sides of the coordinate range and compresses the center. Effectively what that means is that it smooths out transition from 0 to 1 in various ways. Based on Inigo Quilez’s article. ",
    "url": "/raytk/reference/operators/function/gainFn",
    "relUrl": "/reference/operators/function/gainFn"
  },"257": {
    "doc": "impulseFn",
    "title": "impulseFn",
    "content": "Impulse functions that are useful as trigger patterns or animation envelopes. Based on Inigo Quilez’s article. ",
    "url": "/raytk/reference/operators/function/impulseFn",
    "relUrl": "/reference/operators/function/impulseFn"
  },"258": {
    "doc": "Function Operators",
    "title": "Function Operators",
    "content": "Function operators are an advanced type of operator used to control the behavior of other types of operators. They are similar to field operators, but rather than providing values based on positions in space, they take in and modify simple numeric values. For example, they can be used to control the curve used to smooth the blending region of a magnet operator, with either a sudden edge, or various types of smoothed transitions. ",
    "url": "/raytk/reference/operators/function/",
    "relUrl": "/reference/operators/function/"
  },"259": {
    "doc": "joinFn",
    "title": "joinFn",
    "content": "Joins functions end on end. ",
    "url": "/raytk/reference/operators/function/joinFn",
    "relUrl": "/reference/operators/function/joinFn"
  },"260": {
    "doc": "modulateFn",
    "title": "modulateFn",
    "content": " ",
    "url": "/raytk/reference/operators/function/modulateFn",
    "relUrl": "/reference/operators/function/modulateFn"
  },"261": {
    "doc": "multiplyFn",
    "title": "multiplyFn",
    "content": "Multiplies the returned values produced by all of the connected input functions. ",
    "url": "/raytk/reference/operators/function/multiplyFn",
    "relUrl": "/reference/operators/function/multiplyFn"
  },"262": {
    "doc": "parabolaFn",
    "title": "parabolaFn",
    "content": " ",
    "url": "/raytk/reference/operators/function/parabolaFn",
    "relUrl": "/reference/operators/function/parabolaFn"
  },"263": {
    "doc": "pausingWaveFn",
    "title": "pausingWaveFn",
    "content": " ",
    "url": "/raytk/reference/operators/function/pausingWaveFn",
    "relUrl": "/reference/operators/function/pausingWaveFn"
  },"264": {
    "doc": "pennerEasingFn",
    "title": "pennerEasingFn",
    "content": "Robert Penner’s collection of easing functions. Based on glsl-easings. See easings.net for a useful reference. ",
    "url": "/raytk/reference/operators/function/pennerEasingFn",
    "relUrl": "/reference/operators/function/pennerEasingFn"
  },"265": {
    "doc": "powerCurveFn",
    "title": "powerCurveFn",
    "content": " ",
    "url": "/raytk/reference/operators/function/powerCurveFn",
    "relUrl": "/reference/operators/function/powerCurveFn"
  },"266": {
    "doc": "rainbowFn",
    "title": "rainbowFn",
    "content": " ",
    "url": "/raytk/reference/operators/function/rainbowFn",
    "relUrl": "/reference/operators/function/rainbowFn"
  },"267": {
    "doc": "sincCurveFn",
    "title": "sincCurveFn",
    "content": " ",
    "url": "/raytk/reference/operators/function/sincCurveFn",
    "relUrl": "/reference/operators/function/sincCurveFn"
  },"268": {
    "doc": "stepFn",
    "title": "stepFn",
    "content": "A function that changes from zero to one at a cutoff point. ",
    "url": "/raytk/reference/operators/function/stepFn",
    "relUrl": "/reference/operators/function/stepFn"
  },"269": {
    "doc": "waveFn",
    "title": "waveFn",
    "content": "A function that uses a periodic wave, with the position as the parameter. ",
    "url": "/raytk/reference/operators/function/waveFn",
    "relUrl": "/reference/operators/function/waveFn"
  },"270": {
    "doc": "Operators",
    "title": "Operator Categories",
    "content": ". | Camera - Operators that are used in raymarching to determine which direction rays should travel, effectively behaving as cameras. | Combine - Operators that take two or more inputs and combine them into a single output. | Convert - Operators that convert between different types of coordinates and return types (SDF, float/vector field, etc). | Custom - Custom operators can be used to write custom GLSL code and run it in the context of a RayTK scene. | Field - Float or vector fields, which provide values for the requested coordinates. | Filter - Operators that take an input and modify it. | Function - Function operators are an advanced type of operator used to control the behavior of other types of operators. | Light - Operators that are used in raymarching to define the behavior of light, including light sources and shadow behaviors. | Material - Material operators that are used by renderers to determine the color of points on the surface of geometry. | Output - Outputs are a special category of operator that takes in one or more chains of OPs, generate a shader, and run it to produce some sort of output. | Pattern - 2D pattern generators, which can be used for things like textures. Pattern operators are essentially a sub-category of field operators that focus on producing value or color patterns using 2D coordinates. | Post - Post processing operators are components that take information from a renderer and process it to produce images that can be used for post-processing. | Sdf - Signed distances functions which define geometry in 3D space, by calculating the distance from the surface of the shape at any given point. | Sdf2d - Signed distances functions which define geometry in 2D space, by calculating the distance from the edge of the shape at any given point. | Time - Operators that do time-based calculations. | Utility - Advanced operators that change how ROP chains behave. | Volume - None | . ",
    "url": "/raytk/reference/operators/#operator-categories",
    "relUrl": "/reference/operators/#operator-categories"
  },"271": {
    "doc": "Operators",
    "title": "Operators",
    "content": " ",
    "url": "/raytk/reference/operators/",
    "relUrl": "/reference/operators/"
  },"272": {
    "doc": "ambientLight",
    "title": "ambientLight",
    "content": "Ambient light source that doesn’t come from a particular location. As far as a material is concerned, an ambient light is always right in front of any point on a surface. Use cases for this are relatively rare. ",
    "url": "/raytk/reference/operators/light/ambientLight",
    "relUrl": "/reference/operators/light/ambientLight"
  },"273": {
    "doc": "axisLight",
    "title": "axisLight",
    "content": "Light that emits from along an axis, similar to an infinitely long tube light. ",
    "url": "/raytk/reference/operators/light/axisLight",
    "relUrl": "/reference/operators/light/axisLight"
  },"274": {
    "doc": "directionalLight",
    "title": "directionalLight",
    "content": "Directional or distant light which always comes from one direction. The light always comes from the specified direction, rather than from a point. ",
    "url": "/raytk/reference/operators/light/directionalLight",
    "relUrl": "/reference/operators/light/directionalLight"
  },"275": {
    "doc": "hardShadow",
    "title": "hardShadow",
    "content": "A simple hard-edged shadow. This should be connected to the “Shadow” input of the raymarchRender3d operator. ",
    "url": "/raytk/reference/operators/light/hardShadow",
    "relUrl": "/reference/operators/light/hardShadow"
  },"276": {
    "doc": "Light Operators",
    "title": "Light Operators",
    "content": "Operators that are used in raymarching to define the behavior of light, including light sources and shadow behaviors. These operators are generally specialized for use in the raymarching LightContext and may not support being fed through other OPs like filters. ",
    "url": "/raytk/reference/operators/light/",
    "relUrl": "/reference/operators/light/"
  },"277": {
    "doc": "instanceLight",
    "title": "instanceLight",
    "content": " ",
    "url": "/raytk/reference/operators/light/instanceLight",
    "relUrl": "/reference/operators/light/instanceLight"
  },"278": {
    "doc": "lightVolume",
    "title": "lightVolume",
    "content": " ",
    "url": "/raytk/reference/operators/light/lightVolume",
    "relUrl": "/reference/operators/light/lightVolume"
  },"279": {
    "doc": "linkedLight",
    "title": "linkedLight",
    "content": "Light that is based on a standard Light COMP. This can be used to synchronize lighting between a raymarchRender3d and a traditional Render TOP. Not all light types are supported. ",
    "url": "/raytk/reference/operators/light/linkedLight",
    "relUrl": "/reference/operators/light/linkedLight"
  },"280": {
    "doc": "multiLight",
    "title": "multiLight",
    "content": "Combines multiple light sources. This causes the renderer to repeat the surface shading process for each light and then combine the results. If shadows are enabled, this can have a significant impact on performance. Each light source can optionally specify an SDF that defines the bounds of the area where that light is used. This can help to optimize rendering if one light is only needed in certain areas. ",
    "url": "/raytk/reference/operators/light/multiLight",
    "relUrl": "/reference/operators/light/multiLight"
  },"281": {
    "doc": "pointLight",
    "title": "pointLight",
    "content": "Light that emits from a single point in space. ",
    "url": "/raytk/reference/operators/light/pointLight",
    "relUrl": "/reference/operators/light/pointLight"
  },"282": {
    "doc": "ringLight",
    "title": "ringLight",
    "content": "Light that emits from a torus or ring shape. ",
    "url": "/raytk/reference/operators/light/ringLight",
    "relUrl": "/reference/operators/light/ringLight"
  },"283": {
    "doc": "softShadow",
    "title": "softShadow",
    "content": "A soft-edged shadow. This should be connected to the “Shadow” input of the raymarchRender3d operator. ",
    "url": "/raytk/reference/operators/light/softShadow",
    "relUrl": "/reference/operators/light/softShadow"
  },"284": {
    "doc": "spotLight",
    "title": "spotLight",
    "content": "Cone-shaped spotlight. This is similar to the Light COMP in spotlight mode. ",
    "url": "/raytk/reference/operators/light/spotLight",
    "relUrl": "/reference/operators/light/spotLight"
  },"285": {
    "doc": "volumetricRayCast",
    "title": "volumetricRayCast",
    "content": " ",
    "url": "/raytk/reference/operators/light/volumetricRayCast",
    "relUrl": "/reference/operators/light/volumetricRayCast"
  },"286": {
    "doc": "backgroundFieldContrib",
    "title": "backgroundFieldContrib",
    "content": "Accesses color from the background field of the renderer, which is based on the surface normal, for use in a modularMat. ",
    "url": "/raytk/reference/operators/material/backgroundFieldContrib",
    "relUrl": "/reference/operators/material/backgroundFieldContrib"
  },"287": {
    "doc": "basicMat",
    "title": "basicMat",
    "content": "Material with a basic lighting model. The material combines several elements to determine the color of a given surface point. First, the base color uses the Basecolor parameter and optionally the Base Color Field input. Next, the specular color uses the color and relative position of the light. Third, the “Sky” color acts as a simple pseudo light, that uses the surface normal but doesn’t support shadows. ",
    "url": "/raytk/reference/operators/material/basicMat",
    "relUrl": "/reference/operators/material/basicMat"
  },"288": {
    "doc": "colorizeSdf2d",
    "title": "colorizeSdf2d",
    "content": "Converts a 2D SDF to a striped distance pattern. This pattern is useful for debugging purposes. While this is not a regular “material”, it is used to convert an SDF to a color output. ",
    "url": "/raytk/reference/operators/material/colorizeSdf2d",
    "relUrl": "/reference/operators/material/colorizeSdf2d"
  },"289": {
    "doc": "diffuseContrib",
    "title": "diffuseContrib",
    "content": "A material element that provides diffuse light contribution. ",
    "url": "/raytk/reference/operators/material/diffuseContrib",
    "relUrl": "/reference/operators/material/diffuseContrib"
  },"290": {
    "doc": "goochShadingContrib",
    "title": "goochShadingContrib",
    "content": "A material element that uses the Gooch shading model. It produces colors that are based on the surface normal. It is useful for showing the 3D structure of a shape rather than using realistic lighting-based color. See Gooch Shading. This is equivalent to the goochMat, for use in a modular material. ",
    "url": "/raytk/reference/operators/material/goochShadingContrib",
    "relUrl": "/reference/operators/material/goochShadingContrib"
  },"291": {
    "doc": "hologramContrib",
    "title": "hologramContrib",
    "content": " ",
    "url": "/raytk/reference/operators/material/hologramContrib",
    "relUrl": "/reference/operators/material/hologramContrib"
  },"292": {
    "doc": "Material Operators",
    "title": "Material Operators",
    "content": "Material operators that are used by renderers to determine the color of points on the surface of geometry. These operators are specialized to work in the MaterialContext and may not support being fed through other OPs like filters. ",
    "url": "/raytk/reference/operators/material/",
    "relUrl": "/reference/operators/material/"
  },"293": {
    "doc": "iridescenceContrib",
    "title": "iridescenceContrib",
    "content": "Shading element that produces a rainbow pattern around the edges of shapes, depending on which direction the surface is facing (the surface normal). ",
    "url": "/raytk/reference/operators/material/iridescenceContrib",
    "relUrl": "/reference/operators/material/iridescenceContrib"
  },"294": {
    "doc": "matCapContrib",
    "title": "matCapContrib",
    "content": "Shading using a MatCap (Material Capture) image to fake lighting and reflections. MatCap images are available on github. Note that this shading does not use actual lights or reflections, it’s a shortcut that fakes those things which are pre-computed and baked into the images that the shading is based on. This approach is commonly used in sculpting tools like zBrush. ",
    "url": "/raytk/reference/operators/material/matCapContrib",
    "relUrl": "/reference/operators/material/matCapContrib"
  },"295": {
    "doc": "modularMat",
    "title": "modularMat",
    "content": "A material that is composed of one or more shading elements. The shading contribution operators are intended to be used with this material, including diffuseContrib, specularContrib, and skyLightContrib. However any float or vector field operator can be used as a lighting element as long as it’s set up to use MaterialContext. ",
    "url": "/raytk/reference/operators/material/modularMat",
    "relUrl": "/reference/operators/material/modularMat"
  },"296": {
    "doc": "pbrMat",
    "title": "pbrMat",
    "content": " ",
    "url": "/raytk/reference/operators/material/pbrMat",
    "relUrl": "/reference/operators/material/pbrMat"
  },"297": {
    "doc": "phongMat",
    "title": "phongMat",
    "content": "Material that uses phong shading. Deprecated in favor of using Phong mode in specularContrib in a modularMat. ",
    "url": "/raytk/reference/operators/material/phongMat",
    "relUrl": "/reference/operators/material/phongMat"
  },"298": {
    "doc": "reflectContrib",
    "title": "reflectContrib",
    "content": "A material element that produces color based on light reflected from other surfaces. In order for this to work, reflection support needs to be enabled in the renderer. ",
    "url": "/raytk/reference/operators/material/reflectContrib",
    "relUrl": "/reference/operators/material/reflectContrib"
  },"299": {
    "doc": "reflectMat",
    "title": "reflectMat",
    "content": " ",
    "url": "/raytk/reference/operators/material/reflectMat",
    "relUrl": "/reference/operators/material/reflectMat"
  },"300": {
    "doc": "rimContrib",
    "title": "rimContrib",
    "content": "Shading that is applied to the edges of a surface relative to where it’s viewed from. This is similar to the Rim Light feature in a standard Phong MAT. Using rim shading can result in aliasing issues, since it’s essentially highlighting the areas that are most likely to have aliasing. ",
    "url": "/raytk/reference/operators/material/rimContrib",
    "relUrl": "/reference/operators/material/rimContrib"
  },"301": {
    "doc": "sampledPointMat",
    "title": "sampledPointMat",
    "content": "A material that produces color for volumetric points relative to the input shape. This is intended for use with pointMapRender. It isn’t useful for raymarchRender3d since that renderer only evaluates materials at points on the surface of the shape, and not inside/outside the shape. ",
    "url": "/raytk/reference/operators/material/sampledPointMat",
    "relUrl": "/reference/operators/material/sampledPointMat"
  },"302": {
    "doc": "shadingProperty",
    "title": "shadingProperty",
    "content": " ",
    "url": "/raytk/reference/operators/material/shadingProperty",
    "relUrl": "/reference/operators/material/shadingProperty"
  },"303": {
    "doc": "shadowContrib",
    "title": "shadowContrib",
    "content": "A material element that produces the shading level for the surface. The shading level will be 1 in areas without a shadow, and 0 in areas that are fully in shadow. ",
    "url": "/raytk/reference/operators/material/shadowContrib",
    "relUrl": "/reference/operators/material/shadowContrib"
  },"304": {
    "doc": "skyLightContrib",
    "title": "skyLightContrib",
    "content": "A material element that acts as a basic pseudo directional light. It applies lighting based on the direction that surfaces are facing. Unlike the main lighting system, it does not support shadows or other lighting behavior. It is a cheap way to add some secondary coloration to surfaces. It is equivalent to the sky lighting feature in basicMat. ",
    "url": "/raytk/reference/operators/material/skyLightContrib",
    "relUrl": "/reference/operators/material/skyLightContrib"
  },"305": {
    "doc": "specularContrib",
    "title": "specularContrib",
    "content": "A material element that provides specular light contribution. ",
    "url": "/raytk/reference/operators/material/specularContrib",
    "relUrl": "/reference/operators/material/specularContrib"
  },"306": {
    "doc": "subsurfaceContrib",
    "title": "subsurfaceContrib",
    "content": " ",
    "url": "/raytk/reference/operators/material/subsurfaceContrib",
    "relUrl": "/reference/operators/material/subsurfaceContrib"
  },"307": {
    "doc": "surfaceColorContrib",
    "title": "surfaceColorContrib",
    "content": "A material element that produces the assigned color attribute for the surface. If no color attribute has been assigned to the surface, this will use the Default Color instead. ",
    "url": "/raytk/reference/operators/material/surfaceColorContrib",
    "relUrl": "/reference/operators/material/surfaceColorContrib"
  },"308": {
    "doc": "toonShadingContrib",
    "title": "toonShadingContrib",
    "content": "Modular shading element which uses a cell/toon shading technique with a color ramp. ",
    "url": "/raytk/reference/operators/material/toonShadingContrib",
    "relUrl": "/reference/operators/material/toonShadingContrib"
  },"309": {
    "doc": "customRender",
    "title": "customRender",
    "content": " ",
    "url": "/raytk/reference/operators/output/customRender",
    "relUrl": "/reference/operators/output/customRender"
  },"310": {
    "doc": "fieldRender",
    "title": "fieldRender",
    "content": " ",
    "url": "/raytk/reference/operators/output/fieldRender",
    "relUrl": "/reference/operators/output/fieldRender"
  },"311": {
    "doc": "functionGraphRender",
    "title": "functionGraphRender",
    "content": "Visualizes the graph of a function operator. This is intended primarily for use in the Inspector, though there may be other uses. It can take in multiple function inputs, which it will visualize with different colors of lines in the same graph. It provides several outputs: . | Color - The rendered graph line. | GUI - The graph line along with axes and range markers. | . ",
    "url": "/raytk/reference/operators/output/functionGraphRender",
    "relUrl": "/reference/operators/output/functionGraphRender"
  },"312": {
    "doc": "Output Operators",
    "title": "Output Operators",
    "content": "Outputs are a special category of operator that takes in one or more chains of OPs, generate a shader, and run it to produce some sort of output. The most common one is raymarchRender3d, which takes in a chain of OPs that produces an SDF in 3D space, and applies raymarching to render an image. ",
    "url": "/raytk/reference/operators/output/",
    "relUrl": "/reference/operators/output/"
  },"313": {
    "doc": "pointMapRender",
    "title": "pointMapRender",
    "content": "Renderer that takes in a TOP of coordinates and evaluates the scene at each point. The primary use for this is with TOP-based instancing for a Geometry COMP: . | Create a TOP with a coordinate value in each pixel. For example, this could be point cloud data, or converted points from a SOP/CHOP. | Create your RayTK scene network, with an SDF or value/vector field. | (Optionally) add a sampledPointMat to the scene to control how colors are applied to shapes. | Create a pointMapRender, and connect the scene to the first input and the coordinate TOP to the TOP input. | The TOP that comes out of the “Color” output will be a TOP with the same dimensions as the coordinate TOP, with a color value for each pixel, based on the scene. | On a Geometry COMP, with instancing on, use the coordinate TOP for the instance positions, and use the colors TOP from the pointMapRender for the instance colors. | . Other uses include: . | LED pixel mapping, where you use the physical location of each LED for the coordinates, and apply the resulting colors to each LED. | GPU particles, where the simulation GLSL TOP produces coordinates from one buffer, which are run through the pointMapRender, and then feed the resulting values back into the simulation to control particle forces for each particle/pixel. | . The “SDF or Value” output, when using an SDF scene, will output values where the RGB channels contain the distance to the surface. The alpha channel will be one for points that existed in the input map and zero for ones that did not. In other words the alpha channel will be the same as the alpha channel in the input point map. ",
    "url": "/raytk/reference/operators/output/pointMapRender",
    "relUrl": "/reference/operators/output/pointMapRender"
  },"314": {
    "doc": "raymarchPreviewPanel",
    "title": "raymarchPreviewPanel",
    "content": " ",
    "url": "/raytk/reference/operators/output/raymarchPreviewPanel",
    "relUrl": "/reference/operators/output/raymarchPreviewPanel"
  },"315": {
    "doc": "raymarchRender3D",
    "title": "raymarchRender3D",
    "content": "Renders a scene using 3D raymarching. ",
    "url": "/raytk/reference/operators/output/raymarchRender3D",
    "relUrl": "/reference/operators/output/raymarchRender3D"
  },"316": {
    "doc": "render2D",
    "title": "render2D",
    "content": "Renders a 2D image by evaluating the input field for each pixel. The input field can return either vec4 which is used as RGBA, or a float, which is copied to all 4 channels. The input field can use either 2D coordinates, or 1D, in which case it only uses the X axis and renders the same result for each vertical line of pixels. ",
    "url": "/raytk/reference/operators/output/render2D",
    "relUrl": "/reference/operators/output/render2D"
  },"317": {
    "doc": "renderSelect",
    "title": "renderSelect",
    "content": "Accesses a color output buffer from a renderer. See Output Buffers for more details. ",
    "url": "/raytk/reference/operators/output/renderSelect",
    "relUrl": "/reference/operators/output/renderSelect"
  },"318": {
    "doc": "texture3dRender",
    "title": "texture3dRender",
    "content": "Renderer that produces 3D textures that sample SDFs, Volumes, or fields. When rendering a field (either float or vector), it just produces the field value as the main output. When rendering an SDF, it produces the SDF’s assigned density in the main output. If the SDF doesn’t have a density, it will fill the interior with a density of 1 and the exterior with a density of 0. The color output uses a material if one is assigned to the SDF, or the SDF’s color if it has one, or white on the interior if it doesn’t. When rendering a volume, it produces the density value as the main output. The color output uses the volume’s color attribute if it has one, with the density value as the alpha. If the volume doesn’t have a color attribute, it will produce 0. The renderer defines a box-shaped area to sample and fills the 3D texture with the results of the sampling. ",
    "url": "/raytk/reference/operators/output/texture3dRender",
    "relUrl": "/reference/operators/output/texture3dRender"
  },"319": {
    "doc": "volumetricRaymarchRender3D",
    "title": "volumetricRaymarchRender3D",
    "content": "Renderer that uses raymarching with volumes instead of SDFs. Note that this renderer is actively being developed, so it may have some bugs or limitations. This renderer uses steps that have a constant size, rather than stepping different distances based on how far an SDF says they are from the surface. This makes it more suitable for volumes that are based on fields of density rather than SDFs. There are two main modes: Solid and Cloud. Solid mode behaves similarly to regular raymarching, where the rays stop once they hit an area with a density of 1 or more. Then it uses shading similar to a regular raymarchRender3D. This mode works best with volumes that are based on SDFs. Cloud mode sends rays through the volume, and at each step, it checks the density of the volume. Rays don’t stop marching until they go through the bounding area. The density and color accumulate as the rays go through the volume to produce the final results. ",
    "url": "/raytk/reference/operators/output/volumetricRaymarchRender3D",
    "relUrl": "/reference/operators/output/volumetricRaymarchRender3D"
  },"320": {
    "doc": "blobRingPattern",
    "title": "blobRingPattern",
    "content": " ",
    "url": "/raytk/reference/operators/pattern/blobRingPattern",
    "relUrl": "/reference/operators/pattern/blobRingPattern"
  },"321": {
    "doc": "brickPattern",
    "title": "brickPattern",
    "content": "Pattern of stacked rectangular bricks. This pattern produces just float values not colors. To apply color to it, pass it into a colorRampField. The bricks themselves produce values of 0 (or black) and the spaces between them produce values of 1 (or white). ",
    "url": "/raytk/reference/operators/pattern/brickPattern",
    "relUrl": "/reference/operators/pattern/brickPattern"
  },"322": {
    "doc": "checkerPattern",
    "title": "checkerPattern",
    "content": "Checkerboard pattern with alternating black and white rectangles. This pattern produces just float values not colors. To apply color to it, pass it into a colorRampField. ",
    "url": "/raytk/reference/operators/pattern/checkerPattern",
    "relUrl": "/reference/operators/pattern/checkerPattern"
  },"323": {
    "doc": "gridPattern",
    "title": "gridPattern",
    "content": "Rectangular grid pattern. This operator produces different types of values from the grid depending on the selected Format. ",
    "url": "/raytk/reference/operators/pattern/gridPattern",
    "relUrl": "/reference/operators/pattern/gridPattern"
  },"324": {
    "doc": "hexagonalGridPattern",
    "title": "hexagonalGridPattern",
    "content": "Hexagonal grid pattern. This operator produces different types of values from the grid depending on the selected Pattern. ",
    "url": "/raytk/reference/operators/pattern/hexagonalGridPattern",
    "relUrl": "/reference/operators/pattern/hexagonalGridPattern"
  },"325": {
    "doc": "hexagonalTruchetPattern",
    "title": "hexagonalTruchetPattern",
    "content": "Pattern using truchet tiling in a hexagonal arrangement. This operator produces different types of values from the grid depending on the selected Pattern. Truchet patterns involve a curving path through a grid (in this case hexagonal), where the path is always uninterrupted, but may sometimes form closed loops. Based on hexagonal truchet by FabriceNeyret2. See details about Truchet tiles. ",
    "url": "/raytk/reference/operators/pattern/hexagonalTruchetPattern",
    "relUrl": "/reference/operators/pattern/hexagonalTruchetPattern"
  },"326": {
    "doc": "hexagonalWeavePattern",
    "title": "hexagonalWeavePattern",
    "content": "Pattern with two layers with gaps in a hexagonal layout. This pattern always produces colors (vectors), but the Format parameter controls how those colors are produced. ",
    "url": "/raytk/reference/operators/pattern/hexagonalWeavePattern",
    "relUrl": "/reference/operators/pattern/hexagonalWeavePattern"
  },"327": {
    "doc": "Pattern Operators",
    "title": "Pattern Operators",
    "content": "2D pattern generators, which can be used for things like textures. Pattern operators are essentially a sub-category of field operators that focus on producing value or color patterns using 2D coordinates. ",
    "url": "/raytk/reference/operators/pattern/",
    "relUrl": "/reference/operators/pattern/"
  },"328": {
    "doc": "knitPattern",
    "title": "knitPattern",
    "content": "Woven yarn pattern. Note that this pattern has a lot of fine detail which does not work well for things like offsetting SDF surfaces, unless the Texture Amount is set to 0. ",
    "url": "/raytk/reference/operators/pattern/knitPattern",
    "relUrl": "/reference/operators/pattern/knitPattern"
  },"329": {
    "doc": "rosettePattern",
    "title": "rosettePattern",
    "content": "Pattern with overlapping circles in a hexagonal arrangement. This pattern produces just float values not colors. To apply color to it, pass it into a colorRampField. The edges of the circles produce values of 1 and the background produces values of 0. ",
    "url": "/raytk/reference/operators/pattern/rosettePattern",
    "relUrl": "/reference/operators/pattern/rosettePattern"
  },"330": {
    "doc": "snubQuadrilePattern",
    "title": "snubQuadrilePattern",
    "content": " ",
    "url": "/raytk/reference/operators/pattern/snubQuadrilePattern",
    "relUrl": "/reference/operators/pattern/snubQuadrilePattern"
  },"331": {
    "doc": "spiralPattern",
    "title": "spiralPattern",
    "content": " ",
    "url": "/raytk/reference/operators/pattern/spiralPattern",
    "relUrl": "/reference/operators/pattern/spiralPattern"
  },"332": {
    "doc": "tilingPattern",
    "title": "tilingPattern",
    "content": " ",
    "url": "/raytk/reference/operators/pattern/tilingPattern",
    "relUrl": "/reference/operators/pattern/tilingPattern"
  },"333": {
    "doc": "triangleCheckerPattern",
    "title": "triangleCheckerPattern",
    "content": "Triangular grid checkerboard pattern. This pattern produces just float values not colors. To apply color to it, pass it into a colorRampField. ",
    "url": "/raytk/reference/operators/pattern/triangleCheckerPattern",
    "relUrl": "/reference/operators/pattern/triangleCheckerPattern"
  },"334": {
    "doc": "truchetPattern",
    "title": "truchetPattern",
    "content": " ",
    "url": "/raytk/reference/operators/pattern/truchetPattern",
    "relUrl": "/reference/operators/pattern/truchetPattern"
  },"335": {
    "doc": "waveGreekFriezePattern",
    "title": "waveGreekFriezePattern",
    "content": " ",
    "url": "/raytk/reference/operators/pattern/waveGreekFriezePattern",
    "relUrl": "/reference/operators/pattern/waveGreekFriezePattern"
  },"336": {
    "doc": "weavePattern",
    "title": "weavePattern",
    "content": " ",
    "url": "/raytk/reference/operators/pattern/weavePattern",
    "relUrl": "/reference/operators/pattern/weavePattern"
  },"337": {
    "doc": "depthMap",
    "title": "depthMap",
    "content": " ",
    "url": "/raytk/reference/operators/post/depthMap",
    "relUrl": "/reference/operators/post/depthMap"
  },"338": {
    "doc": "Post Operators",
    "title": "Post Operators",
    "content": "Post processing operators are components that take information from a renderer and process it to produce images that can be used for post-processing. Most or all of these are not standard RayTK operators that get connected into a renderer and add to the generated shader. ",
    "url": "/raytk/reference/operators/post/",
    "relUrl": "/reference/operators/post/"
  },"339": {
    "doc": "nearHitMap",
    "title": "nearHitMap",
    "content": " ",
    "url": "/raytk/reference/operators/post/nearHitMap",
    "relUrl": "/reference/operators/post/nearHitMap"
  },"340": {
    "doc": "objectIdMask",
    "title": "objectIdMask",
    "content": " ",
    "url": "/raytk/reference/operators/post/objectIdMask",
    "relUrl": "/reference/operators/post/objectIdMask"
  },"341": {
    "doc": "stepMap",
    "title": "stepMap",
    "content": " ",
    "url": "/raytk/reference/operators/post/stepMap",
    "relUrl": "/reference/operators/post/stepMap"
  },"342": {
    "doc": "worldPosMap",
    "title": "worldPosMap",
    "content": "Access the world position values from a raymarchRender3D, scaled to a normalized range. In order for this to work, the associated raymarchRender3D has to have its World Position output enabled. ",
    "url": "/raytk/reference/operators/post/worldPosMap",
    "relUrl": "/reference/operators/post/worldPosMap"
  },"343": {
    "doc": "amazingSurfaceSdf",
    "title": "amazingSurfaceSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/amazingSurfaceSdf",
    "relUrl": "/reference/operators/sdf/amazingSurfaceSdf"
  },"344": {
    "doc": "apollonianSdf",
    "title": "apollonianSdf",
    "content": "Apollonian gasket fractal. Based on Apollonian Statue2 by EvilRyu. ",
    "url": "/raytk/reference/operators/sdf/apollonianSdf",
    "relUrl": "/reference/operators/sdf/apollonianSdf"
  },"345": {
    "doc": "archSdf",
    "title": "archSdf",
    "content": "Arch / doorway. This SDF combines a few parts, which can be toggled on/off. The panel is the flat inner surface that fills the center of the arch. The frame is the outer border of the arch. ",
    "url": "/raytk/reference/operators/sdf/archSdf",
    "relUrl": "/reference/operators/sdf/archSdf"
  },"346": {
    "doc": "bezierSdf",
    "title": "bezierSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/bezierSdf",
    "relUrl": "/reference/operators/sdf/bezierSdf"
  },"347": {
    "doc": "boxFrameSdf",
    "title": "boxFrameSdf",
    "content": "SDF for the squared frame of the edges of a box. ",
    "url": "/raytk/reference/operators/sdf/boxFrameSdf",
    "relUrl": "/reference/operators/sdf/boxFrameSdf"
  },"348": {
    "doc": "boxSdf",
    "title": "boxSdf",
    "content": "SDF for a box, optionally infinite one one axis. ",
    "url": "/raytk/reference/operators/sdf/boxSdf",
    "relUrl": "/reference/operators/sdf/boxSdf"
  },"349": {
    "doc": "bunnySdf",
    "title": "bunnySdf",
    "content": "SDF for a bunny. Because bunnies are important. Based on Neural Stanford Bunny (5 kb) by Blackle Mori. ",
    "url": "/raytk/reference/operators/sdf/bunnySdf",
    "relUrl": "/reference/operators/sdf/bunnySdf"
  },"350": {
    "doc": "capsuleSdf",
    "title": "capsuleSdf",
    "content": "A line or cylinder with rounded ends, between two points. With a small Radius, this can be used to create a line segment. ",
    "url": "/raytk/reference/operators/sdf/capsuleSdf",
    "relUrl": "/reference/operators/sdf/capsuleSdf"
  },"351": {
    "doc": "chainSdf",
    "title": "chainSdf",
    "content": "Chain made of links, with infinite length. Based on Link - distance by iq. ",
    "url": "/raytk/reference/operators/sdf/chainSdf",
    "relUrl": "/reference/operators/sdf/chainSdf"
  },"352": {
    "doc": "chamferBoxSdf",
    "title": "chamferBoxSdf",
    "content": "A box with cropped corners at 45 degree angles. Based on ChamferBox Super Primitive by TLC123 . ",
    "url": "/raytk/reference/operators/sdf/chamferBoxSdf",
    "relUrl": "/reference/operators/sdf/chamferBoxSdf"
  },"353": {
    "doc": "coneSdf",
    "title": "coneSdf",
    "content": "Defines a cone or capped cone shape. ",
    "url": "/raytk/reference/operators/sdf/coneSdf",
    "relUrl": "/reference/operators/sdf/coneSdf"
  },"354": {
    "doc": "crescentSdf",
    "title": "crescentSdf",
    "content": "Rounded crescent shape. Based on Croissant SDF by erratac. ",
    "url": "/raytk/reference/operators/sdf/crescentSdf",
    "relUrl": "/reference/operators/sdf/crescentSdf"
  },"355": {
    "doc": "crossSdf",
    "title": "crossSdf",
    "content": "An SDF for a 3D cross along each axis, with either infinite or limited length. ",
    "url": "/raytk/reference/operators/sdf/crossSdf",
    "relUrl": "/reference/operators/sdf/crossSdf"
  },"356": {
    "doc": "cutSphereSdf",
    "title": "cutSphereSdf",
    "content": "Sphere with part of it cut off, either solid or hollow. Based on CutSphere - distance 3D by iq. ",
    "url": "/raytk/reference/operators/sdf/cutSphereSdf",
    "relUrl": "/reference/operators/sdf/cutSphereSdf"
  },"357": {
    "doc": "cylinderSdf",
    "title": "cylinderSdf",
    "content": "Cylinder, either solid or a hollow tube. ",
    "url": "/raytk/reference/operators/sdf/cylinderSdf",
    "relUrl": "/reference/operators/sdf/cylinderSdf"
  },"358": {
    "doc": "discSdf",
    "title": "discSdf",
    "content": "A flat disc facing the Y axis. Because the disc is infinitely thin, it will only appear as a line when viewed from the side. ",
    "url": "/raytk/reference/operators/sdf/discSdf",
    "relUrl": "/reference/operators/sdf/discSdf"
  },"359": {
    "doc": "dodecahedronFractalSdf",
    "title": "dodecahedronFractalSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/dodecahedronFractalSdf",
    "relUrl": "/reference/operators/sdf/dodecahedronFractalSdf"
  },"360": {
    "doc": "ellipsoidSdf",
    "title": "ellipsoidSdf",
    "content": "Ellipsoid (sphere with different sizes on each axis). Based on Ellipsoid bound by iq. ",
    "url": "/raytk/reference/operators/sdf/ellipsoidSdf",
    "relUrl": "/reference/operators/sdf/ellipsoidSdf"
  },"361": {
    "doc": "generalizedPolyhedronSdf",
    "title": "generalizedPolyhedronSdf",
    "content": "Generates one of several different types of polyhedra. Based on “Generalized Distance Functions” by Akleman and Chen. ",
    "url": "/raytk/reference/operators/sdf/generalizedPolyhedronSdf",
    "relUrl": "/reference/operators/sdf/generalizedPolyhedronSdf"
  },"362": {
    "doc": "geodesicSdf",
    "title": "geodesicSdf",
    "content": "A geodesic polyhedron, optionally with a spike on each face. Based on Geodesic domain manipulation by tdhooper. ",
    "url": "/raytk/reference/operators/sdf/geodesicSdf",
    "relUrl": "/reference/operators/sdf/geodesicSdf"
  },"363": {
    "doc": "gridSdf",
    "title": "gridSdf",
    "content": "An infinite grid shape, along two axes. ",
    "url": "/raytk/reference/operators/sdf/gridSdf",
    "relUrl": "/reference/operators/sdf/gridSdf"
  },"364": {
    "doc": "gyroidSdf",
    "title": "gyroidSdf",
    "content": "Gyroid shape, which is an infinitely connected periodic surface. The Gyroid is constructed using overlapping sine and cosine waves. See wikipedia for more information. ",
    "url": "/raytk/reference/operators/sdf/gyroidSdf",
    "relUrl": "/reference/operators/sdf/gyroidSdf"
  },"365": {
    "doc": "headSdf",
    "title": "headSdf",
    "content": "Human head SDF created by tdhooper. Original: https://www.shadertoy.com/view/wlf3WX . ",
    "url": "/raytk/reference/operators/sdf/headSdf",
    "relUrl": "/reference/operators/sdf/headSdf"
  },"366": {
    "doc": "helixSdf",
    "title": "helixSdf",
    "content": "SDF for a helix (an elongated spiral). There are two variations of the helix: dual and single. The dual variation can do two parallel rails, and supports using a 2D cross-section SDF, but no UV coordinates. The single variation is just one part, and does not support cross-sections, but does have UV coordinates. The single variation is based on Helix Distance by tdhooper. ",
    "url": "/raytk/reference/operators/sdf/helixSdf",
    "relUrl": "/reference/operators/sdf/helixSdf"
  },"367": {
    "doc": "hyperbolicParaboloidSdf",
    "title": "hyperbolicParaboloidSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/hyperbolicParaboloidSdf",
    "relUrl": "/reference/operators/sdf/hyperbolicParaboloidSdf"
  },"368": {
    "doc": "Sdf Operators",
    "title": "Sdf Operators",
    "content": "Signed distances functions which define geometry in 3D space, by calculating the distance from the surface of the shape at any given point. These operators are how geometry is defined for raymarching, and they are often the first operator in a chain that ends with a raymarchRender3d. ",
    "url": "/raytk/reference/operators/sdf/",
    "relUrl": "/reference/operators/sdf/"
  },"369": {
    "doc": "jointSdf",
    "title": "jointSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/jointSdf",
    "relUrl": "/reference/operators/sdf/jointSdf"
  },"370": {
    "doc": "juliaSdf",
    "title": "juliaSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/juliaSdf",
    "relUrl": "/reference/operators/sdf/juliaSdf"
  },"371": {
    "doc": "kaliGeneratorSdf",
    "title": "kaliGeneratorSdf",
    "content": "Fractal SDF based on “Generators” by Kali (https://www.shadertoy.com/view/Xtf3Rn). ",
    "url": "/raytk/reference/operators/sdf/kaliGeneratorSdf",
    "relUrl": "/reference/operators/sdf/kaliGeneratorSdf"
  },"372": {
    "doc": "latticeSdf",
    "title": "latticeSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/latticeSdf",
    "relUrl": "/reference/operators/sdf/latticeSdf"
  },"373": {
    "doc": "lineSeriesSdf",
    "title": "lineSeriesSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/lineSeriesSdf",
    "relUrl": "/reference/operators/sdf/lineSeriesSdf"
  },"374": {
    "doc": "linkSdf",
    "title": "linkSdf",
    "content": "SDF for a chain link shape (an elongated loop). ",
    "url": "/raytk/reference/operators/sdf/linkSdf",
    "relUrl": "/reference/operators/sdf/linkSdf"
  },"375": {
    "doc": "mandelbulbSdf",
    "title": "mandelbulbSdf",
    "content": "Mandelbulb fractal. ",
    "url": "/raytk/reference/operators/sdf/mandelbulbSdf",
    "relUrl": "/reference/operators/sdf/mandelbulbSdf"
  },"376": {
    "doc": "mengerSpongeSdf",
    "title": "mengerSpongeSdf",
    "content": "Menger sponge fractal, made of boxes with holes cut through each axis. ",
    "url": "/raytk/reference/operators/sdf/mengerSpongeSdf",
    "relUrl": "/reference/operators/sdf/mengerSpongeSdf"
  },"377": {
    "doc": "mobiusRingSdf",
    "title": "mobiusRingSdf",
    "content": "SDF for a squared mobius ring, which is like a rectangular bar twisted and then bent into a ring. ",
    "url": "/raytk/reference/operators/sdf/mobiusRingSdf",
    "relUrl": "/reference/operators/sdf/mobiusRingSdf"
  },"378": {
    "doc": "octahedronSdf",
    "title": "octahedronSdf",
    "content": "An octahedron, with its corners facing the axes. ",
    "url": "/raytk/reference/operators/sdf/octahedronSdf",
    "relUrl": "/reference/operators/sdf/octahedronSdf"
  },"379": {
    "doc": "petalSdf",
    "title": "petalSdf",
    "content": "A flower petal or leaf shape. Based on Echeveria by tdhooper. ",
    "url": "/raytk/reference/operators/sdf/petalSdf",
    "relUrl": "/reference/operators/sdf/petalSdf"
  },"380": {
    "doc": "pistonSdf",
    "title": "pistonSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/pistonSdf",
    "relUrl": "/reference/operators/sdf/pistonSdf"
  },"381": {
    "doc": "planeSdf",
    "title": "planeSdf",
    "content": "An infinite plane on the x, y, or z axis. ",
    "url": "/raytk/reference/operators/sdf/planeSdf",
    "relUrl": "/reference/operators/sdf/planeSdf"
  },"382": {
    "doc": "polyhedronSdf",
    "title": "polyhedronSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/polyhedronSdf",
    "relUrl": "/reference/operators/sdf/polyhedronSdf"
  },"383": {
    "doc": "prismSdf",
    "title": "prismSdf",
    "content": "A prism shape, like a cylinder but with flat sides, along the z axis. ",
    "url": "/raytk/reference/operators/sdf/prismSdf",
    "relUrl": "/reference/operators/sdf/prismSdf"
  },"384": {
    "doc": "pyramidSdf",
    "title": "pyramidSdf",
    "content": "A pyramid with four sides. ",
    "url": "/raytk/reference/operators/sdf/pyramidSdf",
    "relUrl": "/reference/operators/sdf/pyramidSdf"
  },"385": {
    "doc": "quadSdf",
    "title": "quadSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/quadSdf",
    "relUrl": "/reference/operators/sdf/quadSdf"
  },"386": {
    "doc": "ringsSdf",
    "title": "ringsSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/ringsSdf",
    "relUrl": "/reference/operators/sdf/ringsSdf"
  },"387": {
    "doc": "segmentedLineSdf",
    "title": "segmentedLineSdf",
    "content": "Multi-segment line SDF. The line is defined my a list of points, which are either defined by parameters or by CHOP channels. ",
    "url": "/raytk/reference/operators/sdf/segmentedLineSdf",
    "relUrl": "/reference/operators/sdf/segmentedLineSdf"
  },"388": {
    "doc": "solidAngleSdf",
    "title": "solidAngleSdf",
    "content": "A conical slice of a sphere. Similar to coneSdf but with the base rounded. ",
    "url": "/raytk/reference/operators/sdf/solidAngleSdf",
    "relUrl": "/reference/operators/sdf/solidAngleSdf"
  },"389": {
    "doc": "sphereFbmSdf",
    "title": "sphereFbmSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/sphereFbmSdf",
    "relUrl": "/reference/operators/sdf/sphereFbmSdf"
  },"390": {
    "doc": "sphereGridSdf",
    "title": "sphereGridSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/sphereGridSdf",
    "relUrl": "/reference/operators/sdf/sphereGridSdf"
  },"391": {
    "doc": "sphereSdf",
    "title": "sphereSdf",
    "content": "SDF in 3D space for a uniform sphere. ",
    "url": "/raytk/reference/operators/sdf/sphereSdf",
    "relUrl": "/reference/operators/sdf/sphereSdf"
  },"392": {
    "doc": "spiralSdf",
    "title": "spiralSdf",
    "content": "A tapering spiral squared tube. Based on Spiral Tiling by Knightly. ",
    "url": "/raytk/reference/operators/sdf/spiralSdf",
    "relUrl": "/reference/operators/sdf/spiralSdf"
  },"393": {
    "doc": "springSdf",
    "title": "springSdf",
    "content": "A coiled spring shape. This is similar to helixSdf, but with the fixed height rather than infinite. ",
    "url": "/raytk/reference/operators/sdf/springSdf",
    "relUrl": "/reference/operators/sdf/springSdf"
  },"394": {
    "doc": "stackSdf",
    "title": "stackSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/stackSdf",
    "relUrl": "/reference/operators/sdf/stackSdf"
  },"395": {
    "doc": "tetrahedronSdf",
    "title": "tetrahedronSdf",
    "content": "Tetrahedron shape. ",
    "url": "/raytk/reference/operators/sdf/tetrahedronSdf",
    "relUrl": "/reference/operators/sdf/tetrahedronSdf"
  },"396": {
    "doc": "torusGridSdf",
    "title": "torusGridSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/torusGridSdf",
    "relUrl": "/reference/operators/sdf/torusGridSdf"
  },"397": {
    "doc": "torusSdf",
    "title": "torusSdf",
    "content": "SDF for a torus. ",
    "url": "/raytk/reference/operators/sdf/torusSdf",
    "relUrl": "/reference/operators/sdf/torusSdf"
  },"398": {
    "doc": "truncatedPyramidSdf",
    "title": "truncatedPyramidSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/truncatedPyramidSdf",
    "relUrl": "/reference/operators/sdf/truncatedPyramidSdf"
  },"399": {
    "doc": "twistedRingsSdf",
    "title": "twistedRingsSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/twistedRingsSdf",
    "relUrl": "/reference/operators/sdf/twistedRingsSdf"
  },"400": {
    "doc": "vesicaSegmentSdf",
    "title": "vesicaSegmentSdf",
    "content": " ",
    "url": "/raytk/reference/operators/sdf/vesicaSegmentSdf",
    "relUrl": "/reference/operators/sdf/vesicaSegmentSdf"
  },"401": {
    "doc": "arbitraryPolygonSdf2d",
    "title": "arbitraryPolygonSdf2d",
    "content": "Polygonal area with arbitrarily positioned points. Points can either be specified with parameters or by passing in a CHOP. If a CHOP is used, only the first N samples are used where N is the Max Points parameter. The first two channels of the CHOP are used for the X and Y, regardless of their names. ",
    "url": "/raytk/reference/operators/sdf2d/arbitraryPolygonSdf2d",
    "relUrl": "/reference/operators/sdf2d/arbitraryPolygonSdf2d"
  },"402": {
    "doc": "arcSdf2d",
    "title": "arcSdf2d",
    "content": "Radial arc, a segment of a circular path, with rounded ends. ",
    "url": "/raytk/reference/operators/sdf2d/arcSdf2d",
    "relUrl": "/reference/operators/sdf2d/arcSdf2d"
  },"403": {
    "doc": "archSdf2d",
    "title": "archSdf2d",
    "content": "Arched doorway shape with a rounded top and rectangular bottom. ",
    "url": "/raytk/reference/operators/sdf2d/archSdf2d",
    "relUrl": "/reference/operators/sdf2d/archSdf2d"
  },"404": {
    "doc": "arrowSdf2d",
    "title": "arrowSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/arrowSdf2d",
    "relUrl": "/reference/operators/sdf2d/arrowSdf2d"
  },"405": {
    "doc": "bezierSdf2d",
    "title": "bezierSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/bezierSdf2d",
    "relUrl": "/reference/operators/sdf2d/bezierSdf2d"
  },"406": {
    "doc": "blobbyCrossSdf2d",
    "title": "blobbyCrossSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/blobbyCrossSdf2d",
    "relUrl": "/reference/operators/sdf2d/blobbyCrossSdf2d"
  },"407": {
    "doc": "branchingTreeSdf2d",
    "title": "branchingTreeSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/branchingTreeSdf2d",
    "relUrl": "/reference/operators/sdf2d/branchingTreeSdf2d"
  },"408": {
    "doc": "chamferRectangleSdf2d",
    "title": "chamferRectangleSdf2d",
    "content": "Rectangle with corners cut off at angles. ",
    "url": "/raytk/reference/operators/sdf2d/chamferRectangleSdf2d",
    "relUrl": "/reference/operators/sdf2d/chamferRectangleSdf2d"
  },"409": {
    "doc": "circleSdf",
    "title": "circleSdf",
    "content": "2D circle SDF. ",
    "url": "/raytk/reference/operators/sdf2d/circleSdf",
    "relUrl": "/reference/operators/sdf2d/circleSdf"
  },"410": {
    "doc": "circleWaveSdf2d",
    "title": "circleWaveSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/circleWaveSdf2d",
    "relUrl": "/reference/operators/sdf2d/circleWaveSdf2d"
  },"411": {
    "doc": "coolSSdf2d",
    "title": "coolSSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/coolSSdf2d",
    "relUrl": "/reference/operators/sdf2d/coolSSdf2d"
  },"412": {
    "doc": "cornerSdf2d",
    "title": "cornerSdf2d",
    "content": "2D SDF for an infinite corner, like an infinite square positioned by one corner. ",
    "url": "/raytk/reference/operators/sdf2d/cornerSdf2d",
    "relUrl": "/reference/operators/sdf2d/cornerSdf2d"
  },"413": {
    "doc": "crossSdf2d",
    "title": "crossSdf2d",
    "content": "2D cross shape SDF, with 4 arms and option rounding of the intersections. ",
    "url": "/raytk/reference/operators/sdf2d/crossSdf2d",
    "relUrl": "/reference/operators/sdf2d/crossSdf2d"
  },"414": {
    "doc": "cutDiscSdf2d",
    "title": "cutDiscSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/cutDiscSdf2d",
    "relUrl": "/reference/operators/sdf2d/cutDiscSdf2d"
  },"415": {
    "doc": "dogBoneSdf2d",
    "title": "dogBoneSdf2d",
    "content": "2D SDF for two connected circles. ",
    "url": "/raytk/reference/operators/sdf2d/dogBoneSdf2d",
    "relUrl": "/reference/operators/sdf2d/dogBoneSdf2d"
  },"416": {
    "doc": "eggSdf2d",
    "title": "eggSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/eggSdf2d",
    "relUrl": "/reference/operators/sdf2d/eggSdf2d"
  },"417": {
    "doc": "ellipseSdf2d",
    "title": "ellipseSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/ellipseSdf2d",
    "relUrl": "/reference/operators/sdf2d/ellipseSdf2d"
  },"418": {
    "doc": "flowerSdf2d",
    "title": "flowerSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/flowerSdf2d",
    "relUrl": "/reference/operators/sdf2d/flowerSdf2d"
  },"419": {
    "doc": "heartSdf2d",
    "title": "heartSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/heartSdf2d",
    "relUrl": "/reference/operators/sdf2d/heartSdf2d"
  },"420": {
    "doc": "hexagonalGridSdf2d",
    "title": "hexagonalGridSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/hexagonalGridSdf2d",
    "relUrl": "/reference/operators/sdf2d/hexagonalGridSdf2d"
  },"421": {
    "doc": "horseshoeSdf2d",
    "title": "horseshoeSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/horseshoeSdf2d",
    "relUrl": "/reference/operators/sdf2d/horseshoeSdf2d"
  },"422": {
    "doc": "Sdf2d Operators",
    "title": "Sdf2d Operators",
    "content": "Signed distances functions which define geometry in 2D space, by calculating the distance from the edge of the shape at any given point. These operators can be used either in 2D workflows, or can be converted to 3D geometry such as by extrusion. ",
    "url": "/raytk/reference/operators/sdf2d/",
    "relUrl": "/reference/operators/sdf2d/"
  },"423": {
    "doc": "isoscelesTriangleSdf2d",
    "title": "isoscelesTriangleSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/isoscelesTriangleSdf2d",
    "relUrl": "/reference/operators/sdf2d/isoscelesTriangleSdf2d"
  },"424": {
    "doc": "jointSdf2d",
    "title": "jointSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/jointSdf2d",
    "relUrl": "/reference/operators/sdf2d/jointSdf2d"
  },"425": {
    "doc": "kochSnowflakeSdf2d",
    "title": "kochSnowflakeSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/kochSnowflakeSdf2d",
    "relUrl": "/reference/operators/sdf2d/kochSnowflakeSdf2d"
  },"426": {
    "doc": "lineSegmentSdf2d",
    "title": "lineSegmentSdf2d",
    "content": "2D line segment SDF. The line segment is defined by two points. By default those come from the “Point A” and “Point B” parameters. But if the “Points Field” input is connected, it will use that to get the points instead. ",
    "url": "/raytk/reference/operators/sdf2d/lineSegmentSdf2d",
    "relUrl": "/reference/operators/sdf2d/lineSegmentSdf2d"
  },"427": {
    "doc": "moonSdf2d",
    "title": "moonSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/moonSdf2d",
    "relUrl": "/reference/operators/sdf2d/moonSdf2d"
  },"428": {
    "doc": "parabolaSdf2d",
    "title": "parabolaSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/parabolaSdf2d",
    "relUrl": "/reference/operators/sdf2d/parabolaSdf2d"
  },"429": {
    "doc": "parallelogramSdf2d",
    "title": "parallelogramSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/parallelogramSdf2d",
    "relUrl": "/reference/operators/sdf2d/parallelogramSdf2d"
  },"430": {
    "doc": "pieSdf2d",
    "title": "pieSdf2d",
    "content": "SDF for a 2D pie-slice shape. ",
    "url": "/raytk/reference/operators/sdf2d/pieSdf2d",
    "relUrl": "/reference/operators/sdf2d/pieSdf2d"
  },"431": {
    "doc": "pistonSdf2d",
    "title": "pistonSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/pistonSdf2d",
    "relUrl": "/reference/operators/sdf2d/pistonSdf2d"
  },"432": {
    "doc": "planeSdf2d",
    "title": "planeSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/planeSdf2d",
    "relUrl": "/reference/operators/sdf2d/planeSdf2d"
  },"433": {
    "doc": "polySplineSdf2d",
    "title": "polySplineSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/polySplineSdf2d",
    "relUrl": "/reference/operators/sdf2d/polySplineSdf2d"
  },"434": {
    "doc": "polygonSdf2d",
    "title": "polygonSdf2d",
    "content": "SDF for several types of 2D polygons. ",
    "url": "/raytk/reference/operators/sdf2d/polygonSdf2d",
    "relUrl": "/reference/operators/sdf2d/polygonSdf2d"
  },"435": {
    "doc": "quadSdf2d",
    "title": "quadSdf2d",
    "content": "SDF for a 2D quad with arbitrary corners. Based on Sierpinski Fractal Cubes by Shane. ",
    "url": "/raytk/reference/operators/sdf2d/quadSdf2d",
    "relUrl": "/reference/operators/sdf2d/quadSdf2d"
  },"436": {
    "doc": "rectangleSdf",
    "title": "rectangleSdf",
    "content": "SDF for a 2D rectangle. ",
    "url": "/raytk/reference/operators/sdf2d/rectangleSdf",
    "relUrl": "/reference/operators/sdf2d/rectangleSdf"
  },"437": {
    "doc": "rhombilleTilingSdf2d",
    "title": "rhombilleTilingSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/rhombilleTilingSdf2d",
    "relUrl": "/reference/operators/sdf2d/rhombilleTilingSdf2d"
  },"438": {
    "doc": "rhombusSdf2d",
    "title": "rhombusSdf2d",
    "content": "SDF for a 2D rhombus (diamond), with its corners aligned to the axes. ",
    "url": "/raytk/reference/operators/sdf2d/rhombusSdf2d",
    "relUrl": "/reference/operators/sdf2d/rhombusSdf2d"
  },"439": {
    "doc": "roundedRectangleSdf2d",
    "title": "roundedRectangleSdf2d",
    "content": "SDF for a 2D rectangle with optionally rounded corners. Each corner has a separate roundness setting, which can be used to make some corners round and others sharp. See ShaderToy for example. ",
    "url": "/raytk/reference/operators/sdf2d/roundedRectangleSdf2d",
    "relUrl": "/reference/operators/sdf2d/roundedRectangleSdf2d"
  },"440": {
    "doc": "spikeSdf2d",
    "title": "spikeSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/spikeSdf2d",
    "relUrl": "/reference/operators/sdf2d/spikeSdf2d"
  },"441": {
    "doc": "spiralSdf2d",
    "title": "spiralSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/spiralSdf2d",
    "relUrl": "/reference/operators/sdf2d/spiralSdf2d"
  },"442": {
    "doc": "stairSdf2d",
    "title": "stairSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/stairSdf2d",
    "relUrl": "/reference/operators/sdf2d/stairSdf2d"
  },"443": {
    "doc": "starSdf2d",
    "title": "starSdf2d",
    "content": "SDF for a 2D star shape. ",
    "url": "/raytk/reference/operators/sdf2d/starSdf2d",
    "relUrl": "/reference/operators/sdf2d/starSdf2d"
  },"444": {
    "doc": "subdivisionSdf2d",
    "title": "subdivisionSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/subdivisionSdf2d",
    "relUrl": "/reference/operators/sdf2d/subdivisionSdf2d"
  },"445": {
    "doc": "superQuadSdf2d",
    "title": "superQuadSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/superQuadSdf2d",
    "relUrl": "/reference/operators/sdf2d/superQuadSdf2d"
  },"446": {
    "doc": "textSdf2d",
    "title": "textSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/textSdf2d",
    "relUrl": "/reference/operators/sdf2d/textSdf2d"
  },"447": {
    "doc": "trapezoidSdf2d",
    "title": "trapezoidSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/trapezoidSdf2d",
    "relUrl": "/reference/operators/sdf2d/trapezoidSdf2d"
  },"448": {
    "doc": "triangleSdf2d",
    "title": "triangleSdf2d",
    "content": "SDF for a 2D triangle. ",
    "url": "/raytk/reference/operators/sdf2d/triangleSdf2d",
    "relUrl": "/reference/operators/sdf2d/triangleSdf2d"
  },"449": {
    "doc": "triangularGridSdf2d",
    "title": "triangularGridSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/triangularGridSdf2d",
    "relUrl": "/reference/operators/sdf2d/triangularGridSdf2d"
  },"450": {
    "doc": "vesicaSdf2d",
    "title": "vesicaSdf2d",
    "content": "SDF for a 2d vesica, which is a shape based on the overlap between two circles. See Wikipedia for details. See ShaderToy for an example. ",
    "url": "/raytk/reference/operators/sdf2d/vesicaSdf2d",
    "relUrl": "/reference/operators/sdf2d/vesicaSdf2d"
  },"451": {
    "doc": "vesicaSegmentSdf2d",
    "title": "vesicaSegmentSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/vesicaSegmentSdf2d",
    "relUrl": "/reference/operators/sdf2d/vesicaSegmentSdf2d"
  },"452": {
    "doc": "wedgeSdf2d",
    "title": "wedgeSdf2d",
    "content": " ",
    "url": "/raytk/reference/operators/sdf2d/wedgeSdf2d",
    "relUrl": "/reference/operators/sdf2d/wedgeSdf2d"
  },"453": {
    "doc": "Time Operators",
    "title": "Time Operators",
    "content": "Operators that do time-based calculations. ",
    "url": "/raytk/reference/operators/time/",
    "relUrl": "/reference/operators/time/"
  },"454": {
    "doc": "lfoField",
    "title": "lfoField",
    "content": " ",
    "url": "/raytk/reference/operators/time/lfoField",
    "relUrl": "/reference/operators/time/lfoField"
  },"455": {
    "doc": "timeField",
    "title": "timeField",
    "content": "Field that produces time-based values, equivalent to a timeline CHOP. This field ignores the provided coordinates and instead returns one of several different types of time-based values. For timeline based values, output operators have a parameter that can specify the time reference operator. Otherwise it uses the timeline scoped to the COMP containing the scene. ",
    "url": "/raytk/reference/operators/time/timeField",
    "relUrl": "/reference/operators/time/timeField"
  },"456": {
    "doc": "timeShift",
    "title": "timeShift",
    "content": "Shifts contextual time for upstream operators, either by a fixed amount or using a value field. ",
    "url": "/raytk/reference/operators/time/timeShift",
    "relUrl": "/reference/operators/time/timeShift"
  },"457": {
    "doc": "exposeValue",
    "title": "exposeValue",
    "content": " ",
    "url": "/raytk/reference/operators/utility/exposeValue",
    "relUrl": "/reference/operators/utility/exposeValue"
  },"458": {
    "doc": "getAttribute",
    "title": "getAttribute",
    "content": " ",
    "url": "/raytk/reference/operators/utility/getAttribute",
    "relUrl": "/reference/operators/utility/getAttribute"
  },"459": {
    "doc": "Utility Operators",
    "title": "Utility Operators",
    "content": "Advanced operators that change how ROP chains behave. ",
    "url": "/raytk/reference/operators/utility/",
    "relUrl": "/reference/operators/utility/"
  },"460": {
    "doc": "injectGlobalPosition",
    "title": "injectGlobalPosition",
    "content": "Calls its input using the untransformed global position. This can be used for fields that are passed to other ops that are using downstream transforms to have the field use the raw global position while being used on an op that is transformed. ",
    "url": "/raytk/reference/operators/utility/injectGlobalPosition",
    "relUrl": "/reference/operators/utility/injectGlobalPosition"
  },"461": {
    "doc": "injectObjectId",
    "title": "injectObjectId",
    "content": "Assigns an arbitrary value to the objectId field of an SDF, which can later be extracted from rendered output. This can be used to identify which object is shown at any given pixel in the output. ",
    "url": "/raytk/reference/operators/utility/injectObjectId",
    "relUrl": "/reference/operators/utility/injectObjectId"
  },"462": {
    "doc": "lfoGenerator",
    "title": "lfoGenerator",
    "content": " ",
    "url": "/raytk/reference/operators/utility/lfoGenerator",
    "relUrl": "/reference/operators/utility/lfoGenerator"
  },"463": {
    "doc": "paramFilter",
    "title": "paramFilter",
    "content": " ",
    "url": "/raytk/reference/operators/utility/paramFilter",
    "relUrl": "/reference/operators/utility/paramFilter"
  },"464": {
    "doc": "providePosition",
    "title": "providePosition",
    "content": " ",
    "url": "/raytk/reference/operators/utility/providePosition",
    "relUrl": "/reference/operators/utility/providePosition"
  },"465": {
    "doc": "provideVariable",
    "title": "provideVariable",
    "content": " ",
    "url": "/raytk/reference/operators/utility/provideVariable",
    "relUrl": "/reference/operators/utility/provideVariable"
  },"466": {
    "doc": "restrictTypes",
    "title": "restrictTypes",
    "content": " ",
    "url": "/raytk/reference/operators/utility/restrictTypes",
    "relUrl": "/reference/operators/utility/restrictTypes"
  },"467": {
    "doc": "speedGenerator",
    "title": "speedGenerator",
    "content": " ",
    "url": "/raytk/reference/operators/utility/speedGenerator",
    "relUrl": "/reference/operators/utility/speedGenerator"
  },"468": {
    "doc": "variableList",
    "title": "variableList",
    "content": " ",
    "url": "/raytk/reference/operators/utility/variableList",
    "relUrl": "/reference/operators/utility/variableList"
  },"469": {
    "doc": "variableReference",
    "title": "variableReference",
    "content": "Accesses the value of a variable provided by another operator. These operators are generally created using the “Reference Variable” option in the editor tools menu. ",
    "url": "/raytk/reference/operators/utility/variableReference",
    "relUrl": "/reference/operators/utility/variableReference"
  },"470": {
    "doc": "fieldVolume",
    "title": "fieldVolume",
    "content": "Creates a Volume based on a density field, and an optional color field. Volumes must have a density, so the density input is required, but color is optional. ",
    "url": "/raytk/reference/operators/volume/fieldVolume",
    "relUrl": "/reference/operators/volume/fieldVolume"
  },"471": {
    "doc": "Volume Operators",
    "title": "Volume Operators",
    "content": " ",
    "url": "/raytk/reference/operators/volume/",
    "relUrl": "/reference/operators/volume/"
  },"472": {
    "doc": "sdfVolume",
    "title": "sdfVolume",
    "content": "Creates a Volume with density based on an SDF. ",
    "url": "/raytk/reference/operators/volume/sdfVolume",
    "relUrl": "/reference/operators/volume/sdfVolume"
  },"473": {
    "doc": "texture3dVolume",
    "title": "texture3dVolume",
    "content": "Creates a Volume based on a 3D texture that contains density values. The volume is defined for a box-shaped area, and the texture is stretched to fill that area. ",
    "url": "/raytk/reference/operators/volume/texture3dVolume",
    "relUrl": "/reference/operators/volume/texture3dVolume"
  },"474": {
    "doc": "The Build Process",
    "title": "The Build Process",
    "content": "The toolkit uses a build process which produces a totally self-contained “built” tox. End users of the toolkit drop one of those built tox files into their projects and use the integrated tools such as the palette to create instances of the types of ROPs defined in the toolkit. ",
    "url": "/raytk/development/build-process/",
    "relUrl": "/development/build-process/"
  },"475": {
    "doc": "The Build Process",
    "title": "Why There is a Build Process",
    "content": "The build process exists to ensure that projects using the toolkit will always work on their own and cannot be broken by changes to dependencies or external files. It also allows developers to work on the toolkit without breaking any of their own projects that use built versions of the toolkit. ",
    "url": "/raytk/development/build-process/#why-there-is-a-build-process",
    "relUrl": "/development/build-process/#why-there-is-a-build-process"
  },"476": {
    "doc": "The Build Process",
    "title": "Toolkit Source",
    "content": "The source used to build the toolkit is defined in a structure of directories and files which are stored an managed in the github repository. The source is split into many files in order to simplify source control and version management. Most COMPs are attached to external files, and most code DAT, tables, and other such data is also synced with external files. ",
    "url": "/raytk/development/build-process/#toolkit-source",
    "relUrl": "/development/build-process/#toolkit-source"
  },"477": {
    "doc": "The Build Process",
    "title": "Versioning",
    "content": "Development on the toolkit is managed by versions, with an associated git branch, and a tag (for completed versions). All development work is done in these versioned branches. When a version is completed, a tag is created along with a release on github. The branch is then merged into master using a pull request. Starting a new version involves starting a new numbered branch off of master, and then the properties of the toolkit tox are updated with the new version. ",
    "url": "/raytk/development/build-process/#versioning",
    "relUrl": "/development/build-process/#versioning"
  },"478": {
    "doc": "The Build Process",
    "title": "The Build Tool",
    "content": "The build tool is a launchable project file named raytk-build.toe. The interface shows some options, a build log, and buttons for performing build-related actions. When starting a build, the tool loads the entire toolkit from the source files, and then walks through it applying various types of modifications. As it does this, it prints messages to the build log, which are shown in the UI. At the end of the process, the tool exports the toolkit tox file, using a name based on the current version (e.g. raytk-0.7.tox). ",
    "url": "/raytk/development/build-process/#the-build-tool",
    "relUrl": "/development/build-process/#the-build-tool"
  },"479": {
    "doc": "The Build Process",
    "title": "Modifications Applied in the Build Process",
    "content": "The build tool performs several types of modifications, including: . | Detaching from external files (such as tox and text files). | Freezing generated data tables and properties. | Detaching cloned COMPs from their masters. | Stripping out development-only items. | Extracting and exporting documentation files. | . ",
    "url": "/raytk/development/build-process/#modifications-applied-in-the-build-process",
    "relUrl": "/development/build-process/#modifications-applied-in-the-build-process"
  },"480": {
    "doc": "The Build Process",
    "title": "OP Tags",
    "content": "The build process looks for several types of tags on OPs and applies different modifications to them. | fileSync: A DAT that is bound to an external text file. During the build process these references are detached and sync is deactivated. This tag is also used in editing tools as an indication that OPs are synced to external files. | buildLock: A DAT or other OP that is dynamically generated while in development mode, but is locked during the build process. This can be used to avoid having to run processes such as searching for OPs when the built toolkit is loaded into a project. | buildExclude: An OP that is stripped out during the build process. For example, OPs used to produce tables that use buildLock are not needed in the built toolkit. Master instances of shared components are also removed (since clones of them are detached during build). | . ",
    "url": "/raytk/development/build-process/#op-tags",
    "relUrl": "/development/build-process/#op-tags"
  },"481": {
    "doc": "The Build Process",
    "title": "Build Scripts",
    "content": " ",
    "url": "/raytk/development/build-process/#build-scripts",
    "relUrl": "/development/build-process/#build-scripts"
  },"482": {
    "doc": "The Build Process",
    "title": "Documentation Processing",
    "content": " ",
    "url": "/raytk/development/build-process/#documentation-processing",
    "relUrl": "/development/build-process/#documentation-processing"
  },"483": {
    "doc": "Documentation Processing",
    "title": "Documentation Processing",
    "content": "The RayTK documentation site is served by GitHub pages, from the main branch of the repository, using the Jekyll Just the Docs theme. The documentation content itself falls several categories: . | Manually written documentation, like this page. | Operator reference pages (example). | Generated index / list pages (example). | . ",
    "url": "/raytk/development/documentation/",
    "relUrl": "/development/documentation/"
  },"484": {
    "doc": "Documentation Processing",
    "title": "Operator Reference Pages",
    "content": "During the build process, the builder generates a page of documentation for each operator. For each operator, documentation is pulled from several sources: . | Manually written Markdown file (not present for all operators) | Metadata from the operator definition | Parameter help | Metadata from inputs | . The manually written documentation files contain: . | Summary paragraph(s) that describe what the operator does | A list of parameters with a description for each (though not all parameters may have written documentation) . | For menu parameters, a list of the menu options with descriptions | . | . The toolkit editor can synchronize the parameter documentation between manually written docs and the help properties of the custom parameters on the operator. During the build process, the builder pulls the help properties for any parameters that don’t appear in the documentation to produce a complete list. Certain special parameters (like Update OP and Inspect) are stripped out from the list. Each inputHandler within the operator can have properties and dynamically generated metadata that describes what the input is used for, whether it’s required, and what coordinate/context/return types it supports. All of this data is compiled together and output into a file in the docs/_reference/ directory. ",
    "url": "/raytk/development/documentation/#operator-reference-pages",
    "relUrl": "/development/documentation/#operator-reference-pages"
  },"485": {
    "doc": "The Raymarching Process",
    "title": "The Raymarching Process",
    "content": "The raymarchRender3D operator takes in an SDF describing a scene, and several other types of inputs, and uses a raymarching process to produce a color for each pixel of output. This page breaks down that process and how different features fit into it. ",
    "url": "/raytk/development/raymarching-process/",
    "relUrl": "/development/raymarching-process/"
  },"486": {
    "doc": "The Raymarching Process",
    "title": "General Outline",
    "content": "At a high level, the raymarching process works like this, for each pixel of output: . | Pick a starting position and a direction for the pixel. | Move a point along that ray (origin position and direction) . | At each step, check the SDF to determine what the closest surface is and how far away it is. | If the closest surface is close enough to be considered a hit, stop the marching process and move to the next stage. | If the point has gone beyond the maximum distance or gone outside the scene bounds, consider it a miss and move on. | If it isn’t a hit, take another step along the ray. | . | If the ray hit a surface, determine a color for it. | If the ray did not hit a surface, determine a background color. | If enabled, a secondary raymarch is done to add color to the result. This is used for volumetric light. | Output the resulting color (and other data like depth). | . ",
    "url": "/raytk/development/raymarching-process/#general-outline",
    "relUrl": "/development/raymarching-process/#general-outline"
  },"487": {
    "doc": "The Raymarching Process",
    "title": "Camera",
    "content": "The camera operator connected to the renderer (or a default internal camera if none is connected) is used to determine where in space the lens is and what direction it’s pointing for each pixel. ",
    "url": "/raytk/development/raymarching-process/#camera",
    "relUrl": "/development/raymarching-process/#camera"
  },"488": {
    "doc": "The Raymarching Process",
    "title": "SDF",
    "content": "The SDF connected to the renderer is used to determine the closest surface to a point in space as well as some properties of that part of the surface. The renderer calls the SDF in a few different parts of the process: . | While marching the ray from the camera into the scene. | When determining surface normals (by checking several nearby points and comparing the results). | When marching a ray from a surface hit towards a light to see if there’s a shadow. | When marching a ray from a surface hit away from the surface to get a reflection color. | . In some of those cases, the additional properties of the surface are relevant (e.g. the material id and uv coordinates). But in other cases, all it cares about is whether a point has hit a surface (calculating normals, checking shadows). For these cases, some operators will skip work that isn’t needed (like calculating uv coordinates). ",
    "url": "/raytk/development/raymarching-process/#sdf",
    "relUrl": "/development/raymarching-process/#sdf"
  },"489": {
    "doc": "The Raymarching Process",
    "title": "Determining Colors For Surface Hits",
    "content": "When a ray has hit a surface, the renderer needs to calculate a color for that spot on the surface. Choosing and Assigning Materials . This is where materials come in. Material operators (such as basicMat or modularMat) insert their unique ID number into the surface properties. The renderer uses those IDs to pick which function (provided by the material operator) it should call to get the color. In cases where combiners are used to merge surfaces, there can be two different material IDs and a ratio of how much to use from each. The surface also ends up with two separate UV coordinates since those may differ. When there are two materials, the renderer calls each of them and then blends the results using the ratio. Preparing MaterialContext . Before the renderer calls the material(s), it packages up some info (refered to as a MaterialContext) that’s required by most materials: . | The surface properties from the SDF (including the assigned surface color property from assignColor) | The origin and direction of the ray that hit the surface. | The position and color of the light. | The surface normal. | This is produced by calling the SDF for several nearby points and comparing the results. | . | The amount of shadow (if enabled). | This is calculated by marching another ray from the surface towards the light to check if anything is blocking it. | . | The reflected color (if enabled). | This is calculated basically by doing the render process from the perspective of that surface hit to get the color that would be reflected onto that spot on the surface. | Depending on the settings, this process may repeat multiple times, bouncing the ray from one surface to another. | . | (Not yet implemented) The refracted color. | UV coordinates relevant to the current material. | Coordinates in space at the point in the process when the material is assigned (referred to as material local position). This allows transforms to be applied after a material is assigned without impacting how the material uses its position to pass to input fields. | . Lights . Lights are called by the renderer when preparing the MaterialContext, to produce a position (where the light is) and a color (which may include adjustments based on the distance from the light). Lights can produce different colors for different surface hits. Lights can also produce different positions for different surface hits. The directionalLight uses this to produce a position that is always in the same direction relative to the surface hit. When multiple lights are used (via multiLight) the renderer repeats the colorization process separately for each light, and then adds the results to get the final color. Using Materials to Produce Colors . When the renderer asks the relevant material for a color for a surface hit, it passes along the info in the MaterialContext. Different materials use different calculations to produce their color. Many materials support inputs that it can call to get parameters (like the base color, or roughness). When they do so, they pass in the MaterialContext, so anything upstream from them can use its properties. The modularMat, when calculating a color, essentially just calls several inputs and adds up the resulting colors. Those inputs are typically operators like specularContrib, but they can be any float/vector field that can work with MaterialContext. ",
    "url": "/raytk/development/raymarching-process/#determining-colors-for-surface-hits",
    "relUrl": "/development/raymarching-process/#determining-colors-for-surface-hits"
  },"490": {
    "doc": "ROP Code",
    "title": "Writing ROP Code",
    "content": "Each ROP has one primary block of “function” code, and several other optional code blocks. Most of these blocks are designed to contain top-level declarations of variables and/or functions. Some blocks are intended to contain a snippet of code that will be inserted into another generated function. | ROP Names | Code Blocks | Preprocessing Applied to Code Blocks | General Guidelines for ROP Code | Parameters | Macros . | Global Macros | . | Types | Inputs | Textures | Buffers | Materials | Contexts . | Default Context . | Context Iteration | . | Camera Context | LightContext | MaterialContext | . | Working with SDF Results | . ",
    "url": "/raytk/development/rop-code/#writing-rop-code",
    "relUrl": "/development/rop-code/#writing-rop-code"
  },"491": {
    "doc": "ROP Code",
    "title": "ROP Names",
    "content": "Each ROP has a unique name generated for it based on the ROP’s path. These names are used throughout the toolkit and the shader code. ",
    "url": "/raytk/development/rop-code/#rop-names",
    "relUrl": "/development/rop-code/#rop-names"
  },"492": {
    "doc": "ROP Code",
    "title": "Code Blocks",
    "content": ". | OP globals: Global declarations such as variables or functions used by the OP. | Init code: A snippet of code that the shader will call before running the rest of the shader code. Typically this is used to set up the values of global variables. | Function: Declaration of the ROP’s primary function. This can also contain supplemental functions used by the primary function. | Material: A snippet of code that is inserted into a function that determines the color for a surface when the surface matches the ROP’s material id. | . ",
    "url": "/raytk/development/rop-code/#code-blocks",
    "relUrl": "/development/rop-code/#code-blocks"
  },"493": {
    "doc": "ROP Code",
    "title": "Preprocessing Applied to Code Blocks",
    "content": "Each block of code is passed through a series of modifications before eventually being injected into the shader. The following symbols are replaced everywhere, even if they are part of a longer symbol (such as THIS_Foo): . | THIS_: The ROP name. This is used as a way to add unique prefixes to function / variable / macro names. | thismap: Also the ROP name. This is intended for the name of the ROP’s primary function. | THISMAT: Unique material ID generated for the ROP (if applicable). This is implemented as a macro that resolves to a unique integer. | inputOp1 - inputOp4: The names of the attached input ROPs. | . The following type aliases are replaced, only when they appear as a whole word without prefix or suffix: . | CoordT: The ROP’s coordinate type. | ContextT: The ROP’s context type. | ReturnT: The ROP’s return type. | . ",
    "url": "/raytk/development/rop-code/#preprocessing-applied-to-code-blocks",
    "relUrl": "/development/rop-code/#preprocessing-applied-to-code-blocks"
  },"494": {
    "doc": "ROP Code",
    "title": "General Guidelines for ROP Code",
    "content": "The generated shader contains combined elements from all of the blocks of all of the ROPs in the scene. This means that any declared symbols used by one ROP can’t conflict with those of any other ROP, including other instances of the same ROP type. To avoid conflicts, all global symbols (functions, variables, macros) should use the THIS_ prefix to keep them unique. ",
    "url": "/raytk/development/rop-code/#general-guidelines-for-rop-code",
    "relUrl": "/development/rop-code/#general-guidelines-for-rop-code"
  },"495": {
    "doc": "ROP Code",
    "title": "Parameters",
    "content": "Each parameter defined by a ROP and listed in the definition’s parameter list and special parameter list will be made available to all code as an alias macro like THIS_Paramname that references whatever the source of the parameter value is. Typically this will be a reference to the uniform array that is used to pass in parameter values. In some cases they could also be inlined values. For multi-part parameters (Par styles including XYZ, RGBA, UV and Float/Int with more than 1 part) the alias evaluates to a value of the relevant vec* type, with the name of the tuplet without any suffix, which combines all of those parts (e.g. THIS_Translate). For parameters in the definition’s “macro” parameter list, an alias will be generated that evaluates to the literal inlined value of that parameter. For numeric parameters, this will be a simple inline float/int value. For menu parameters, there will be a macro evaluating to the selected menu name itself (which is only useful when that is a valid piece of code such as a swizzle like xy). There will also be a macro that appends the selected menu name to the end of the parameter name separated by an underscore (e.g. THIS_Param_value), which is typically used for #ifdef blocks. It is important to remember that because macro-based parameters use inlined values, any changes to them will cause the shader to rebuild. This is both a limitation (if the user wants to be able to change them quickly) and an optimization which avoids having to pass in those values and also allows GPU driver optimizations like dead code removal and loop unrolling. #define PREFIX_Amount vecParams[17].y #define PREFIX_Translatex vecParams[18].x #define PREFIX_Translatey vecParams[18].y #define PREFIX_Translate vec2(vecParams[18].xy) #define PREFIX_Inlined 12.5 #define PREFIX_Plane yz #define PREFIX_Plane_yz . ",
    "url": "/raytk/development/rop-code/#parameters",
    "relUrl": "/development/rop-code/#parameters"
  },"496": {
    "doc": "ROP Code",
    "title": "Macros",
    "content": "Each ROP can define several groups of macros. These are specified in DATs with 3 columns, which can involve evaluating Python expressions. The first column is checked for either False or 0, stripping out those macros. This is used to toggle macros based on expressions. The second column is either the macro name, or the macro name and expression separated by a space. The third column is treated as the macro’s value expression. | 0 | 1 | 2 | . | op(\"foo\")[\"x\"] &gt; 2 | 'THIS_HAS_TWO_THINGS' |   | . |   | 'THIS_USE_THINGS' |   | . |   | 'THIS_STUFF' | 'vec2(0.3, 0.1)' | . |   | 'THIS_FOO 3.5' |   | . Evaluates to: . | 0 | 1 | 2 | . | False | THIS_HAS_TWO_THINGS |   | . |   | 'THIS_USE_THINGS' |   | . |   | THIS_STUFF | vec2(0.3, 0.1) | . |   | THIS_FOO 3.5 |   | . Generates: . #define PREFIX_USE_THINGS #define PREFIX_STUFF vec2(0.3, 0.1) #define PREFIX_FOO 3.5 . Each ROP can have one explicitly defined macro table, and some number of generated tables produced by various helper subcomponents. Global Macros . ROPs can also define a table of “global” macros. These differ from ROP-specific macros in that they are included earlier in the shader before library includes. They are intended to enable features within shared libraries. ",
    "url": "/raytk/development/rop-code/#macros",
    "relUrl": "/development/rop-code/#macros"
  },"497": {
    "doc": "ROP Code",
    "title": "Types",
    "content": "As mentioned above, the symbols CoordT, ContextT and ReturnT are replaced with the relevant types of the ROP. This is implemented using type alias macros such as THIS_CoordT which evaluates to a types such as vec2 or float. Each ROP will also generate macros that append the type name such as THIS_COORD_TYPE_vec2 and THIS_RETURN_TYPE_Sdf. These are typically used for switching blocks of code using #ifdef. #define PREFIX_CoordT vec3 #define PREFIX_ContextT Context #define PREFIX_ReturnT Sdf #define PREFIX_COORD_TYPE_vec3 #define PREFIX_CONTEXT_TYPE_Context #define PREFIX_RETURN_TYPE_Sdf . ",
    "url": "/raytk/development/rop-code/#types",
    "relUrl": "/development/rop-code/#types"
  },"498": {
    "doc": "ROP Code",
    "title": "Inputs",
    "content": "When a ROP has an input definition, aliases like inputOp3 are replaced by the name of that definition. This can be used both as a reference to that ROP’s primary function, and as a prefix for macros. #ifdef inputOp1_COORD_TYPE_vec2 Sdf res = inputOp1(p.xy, ctx); #else Sdf res = inputOp1(p, ctx); #endif . ",
    "url": "/raytk/development/rop-code/#inputs",
    "relUrl": "/development/rop-code/#inputs"
  },"499": {
    "doc": "ROP Code",
    "title": "Textures",
    "content": "A ROP can define a table of textures, each of which have a name and a path to a TOP. Each one will generate a prefixed macro like THIS_textureName. The output OP will use select TOPs to pull from the provided TOPs and feed them into the glsl TOP as inputs. The generated macros refer to the input textures by the index of the attached input. Generated macro: . #define PREFIX_texture sTD2DInputs[3] . Usage in ROP function: . ReturnT thismap(CoordT p, ContextT ctx) { return texture(THIS_texture, p.xy).r; } . ",
    "url": "/raytk/development/rop-code/#textures",
    "relUrl": "/development/rop-code/#textures"
  },"500": {
    "doc": "ROP Code",
    "title": "Buffers",
    "content": " ",
    "url": "/raytk/development/rop-code/#buffers",
    "relUrl": "/development/rop-code/#buffers"
  },"501": {
    "doc": "ROP Code",
    "title": "Materials",
    "content": "ROPs that define materials provide the “Material” code block. These OPs automatically generate a unique integer material identifier, which is made available to the ROP as THISMAT. SDF operators set the material (and/or material2 field in the Sdf struct), which then gets passed along to the ouput shader’s map() function return value. The output shader then inserts the provided code snippet into a generated switch block, which is run when the result’s material id matches the generated material id for the ROP. Typically ROPs will define a prefixed function in their “Function” block and then call it within the “Material” snippet. Function block: . ReturnT thismap(CoordT p, ContextT ctx) { Sdf res = inputOp1(p, ctx); assignMaterial(res, THISMAT); return res; } vec3 THIS_getColor(CoordT p, MaterialContext matCtx) { return THIS_Color; // .... } . Material snippet: . col.rgb = THIS_getColor(p, matCtx); . That snippet is inserted into a function like: . vec3 getColor(vec3 p, MaterialContext matCtx, int m) { vec3 col = vec3(0.); if (m == MAT_PREFIX_1_ETC) { col.rgb = PREFIX_1_getColor(p, matCtx); } else if (m == MAT_PREFIX_2_ABC) { col.rgb = PREFIX_2_getColor(p, matCtx); } //... return col; } . ",
    "url": "/raytk/development/rop-code/#materials",
    "relUrl": "/development/rop-code/#materials"
  },"502": {
    "doc": "ROP Code",
    "title": "Contexts",
    "content": "ROP functions are called with two parameters: a coordinate p, and a secondary context value ctx. The context value contains information about the context for which the function is being called. This includes both fixed global values and values that are modified or provided by one ROP and passed to the input ROPs that it calls. There are several different types of contexts, each used for different reasons that a ROP is being called by the output OP’s shader. Default Context . The Context type is used for the primary call made by the shader to evaluate the scene result. For raymarching, this is for the call at each marching step to evaluate the scene SDF. For 2D rendering, this is for the call made for each pixel to determine the output values. Context Iteration . The Context type includes an iteration field which certain ROPs populate with different values depending on how/where it’s calling an input. The value is a vec4, where the first value is an “index” and the second is a “total count”. The third and fourth are not yet used. Example ROPs that provide iteration values: . | The reflect ROP sets a value of vec4(0, 2, 0, 0) when calling the input if it is one one side of the reflection plane and a value of 1 when calling the input on the other side. | The mirrorOctant ROP sets a different value for each quadrant, vec4(0, 4, 0, 0) for one quadrant, vec4(1, 4, 0, 0) for the next, and so on. | . Several types of ROPs make use of the iteration values passed to them: . | The iterationField ROP will return the iteration in one of several formats (raw index, scaled to total count, full vec4 data, etc). | The iterationSwitch ROP will call one input for index 0 and the other for index 1. | . Camera Context . The CameraContext is used in raymarching when determining the position and direction of the camera ray. It contains information such as the render resolution, which can be used with the normalized UV coordinates in p to calculate values based on pixel offsets. LightContext . The LightContext is used in raymarching when determining the relevant light position and color for a surface ray hit. It includes the surface Sdf result and the surface normal vector. MaterialContext . The MaterialContext is used in raymarching when calculating the color to use for a ray surface hit. It includes the Sdf result, the camera Ray, the computed Light, and other properties used by materials. ",
    "url": "/raytk/development/rop-code/#contexts",
    "relUrl": "/development/rop-code/#contexts"
  },"503": {
    "doc": "ROP Code",
    "title": "Working with SDF Results",
    "content": "The Sdf struct represents a ray hitting a surface (so a more accurate name might be SurfaceHit). It includes information about that surface and properties of the ray process that caused the hit. The struct is the only way that an SDF-based operator can pass value to the ROP that called it. The struct will contain different fields depending on whether those features are being used. For example, if the “Object ID” output buffer is being used, it contains an objectId field. Because the struct can contain different types of fields, it is important to use the provided functions for things like creating and modifying them, rather than manually constructing them. This code is problematic because it fails to account for properties like material blending settings, reflection properties (if those are being used), near hit values (if those are being used), etc: . Sdf badRes; badRes.x = dist; badRes.material = THISMAT; return badRes; . This code uses the provided functions to create and modify the Sdf value, which properly handle all the fields that are being used: . Sdf goodRes = createSdf(dist); assignMaterial(goodRes, THISMAT); return goodRes; . Similarly, when combining two Sdf values, ROPs should use the blendInSdf() function, which appropriately handles all the fields: . Sdf res1 = inputOp1(p, ctx); Sdf res2 = inputOp2(p, ctx); Sdf combinedRes = res1; combinedRes.x = min(res1.x, res2.x); float ratio = smoothBlendRatio(res1.x, res2.x, THIS_Foo); blendInSdf(combinedRes, res2, ratio); return combinedRes; . ",
    "url": "/raytk/development/rop-code/#working-with-sdf-results",
    "relUrl": "/development/rop-code/#working-with-sdf-results"
  },"504": {
    "doc": "ROP Code",
    "title": "ROP Code",
    "content": " ",
    "url": "/raytk/development/rop-code/",
    "relUrl": "/development/rop-code/"
  },"505": {
    "doc": "ROP Elements",
    "title": "ROP Elements",
    "content": "There are several types of reusable sub-components that are used in various ROPs. These components are treated as “elements”, with a standardized data COMP nested inside them. The opDefinition locates these data COMPs and pulls settings from them, which contribute to the contents of the opDefinition. Contributed elements include: . | Parameter specifications | Macros | Blocks of code that can be injected into the ROP code | . ",
    "url": "/raytk/development/rop-elements/",
    "relUrl": "/development/rop-elements/"
  },"506": {
    "doc": "ROP Elements",
    "title": "transformCodeGenerator",
    "content": "The transformCodeGenerator is used in elements that perform standard transformations (translate, rotate, scale, pivot). It generates a block of code that performs the transform with sections for each aspect (e.g. rotation) of the transform that’s enabled and supported by the host ROP. ",
    "url": "/raytk/development/rop-elements/#transformcodegenerator",
    "relUrl": "/development/rop-elements/#transformcodegenerator"
  },"507": {
    "doc": "ROP Elements",
    "title": "aggregateCodeGenerator",
    "content": "The aggregateCodeGenerator is used in ROPs that repeat a chunk of code a variable number of times, depending on how many inputs are connected. Examples include simpleUnion, combineFields, and switch. ",
    "url": "/raytk/development/rop-elements/#aggregatecodegenerator",
    "relUrl": "/development/rop-elements/#aggregatecodegenerator"
  },"508": {
    "doc": "ROP Elements",
    "title": "codeSwitcher",
    "content": "The codeSwitcher is used in ROPs that have a menu parameter that switches between different behaviors. Most menu parameters are implemented using this component, though some are manually written into the ROP code instead. The switcher is based on a table of “options”, where each option has: . | Name | Label | Code snippet | Parameters that it uses | Macros that it applies | Optional other info that ROPs can use for things like changing typeSpec settings. | . ",
    "url": "/raytk/development/rop-elements/#codeswitcher",
    "relUrl": "/development/rop-elements/#codeswitcher"
  },"509": {
    "doc": "ROP Elements",
    "title": "combiner",
    "content": "The combiner is used in ROPs that combine SDF results (e.g. simple union, stair intersect, etc). It is a wrapper around two codeSwitchers, one which is for initial code to prepare parameters and the other is for performing the actual SDF combination. ",
    "url": "/raytk/development/rop-elements/#combiner",
    "relUrl": "/development/rop-elements/#combiner"
  },"510": {
    "doc": "ROP Elements",
    "title": "waveFunction",
    "content": "The waveFunction is used in ROPs that have repeating waves (sine, cosine, square, etc), such as waveField and waveWarp. Similar to the combiner, It is a wrapper around two codeSwitchers, one for preparing parameters and the other for calculating wave result values. ",
    "url": "/raytk/development/rop-elements/#wavefunction",
    "relUrl": "/development/rop-elements/#wavefunction"
  },"511": {
    "doc": "ROP Structure",
    "title": "ROP Structure",
    "content": "ROPs are the core of the RayTK library. A ROP is essentially some chunks of GLSL code, and some metadata. A ROP is a COMP that generates a Definition, which is output as a DAT table. ",
    "url": "/raytk/development/rop-structure/",
    "relUrl": "/development/rop-structure/"
  },"512": {
    "doc": "ROP Structure",
    "title": "ROP Definitions",
    "content": "Inside each ROP there’s an opDefinition component. It includes settings that define the properties of the ROP. OpDefinition Settings . | General settings . | Enable: Whether the ROP should be used or bypassed. Typically this is bound to a parameter of the same name on the ROP itself. | Useruntimebypass: Whether the Enable parameter (if it exists) should be handled like any other runtime parameter, or, when this is false, switching off the Enable parameter totally excludes the OP from the scene, just passing through the first input definition. | Hostop: Reference to the parent ROP. This should always be .. to refer to the parent comp. | Paramsop: Optional reference to an operator that holds the ROP’s parameters. This should be blank except in the rare case of operators that support adding custom parameters like customOp. | Name: Globally unique name for the ROP, based on its path. This should always be an expression that pulls its value from inside the opDefinition. | Style: Optional setting that controls how the ROP’s viewer image appears. In nearly all cases this should be blank. | Librarynames: List of either names of globally available shared shader libraries (raytkCombine) and/or references to DATs inside the ROP that are injected into the shader (deduplicated to avoid conflicts if multiple ROP instances provide equivalent libraries). | Typespec: Reference to the typeSpec component that defines the data types used by the ROP. See below. | Inputdefs: Optional list of additional ROP definition tables to be included as inputs. This is used for cases where there are more than 8 inputs, or when there are inputs that have special handling. | Disableinspect: Whether the ROP supports the Inspect feature to launch the Inspector tool. | . | Code blocks (references to DATs that contain blocks of glsl code) . | Opglobals: Global declarations, such as variables that are shared across multiple calls of the ROP’s main function code. This is not commonly used. | Initcode: Executable code that is called once at the beginning of the shader execution. This can be used to initialize global variables. It is not commonly used. | Functemplate: Required declaration of the ROP’s primary function. It can also include additional functions or other declarations that are specific to this particular instance of this type of ROP. | Materialcode: Optional executable code that materials use to produce colors when rendering. This is only used for material operators (e.g. modularMat, basicMat), and it’s typically just a call to a secondary function that’s defined in the Functemplate. | . | Tables (references to tables that specify one or more items that belong to the ROP). | Macrotable: Compiler macros which produce #defines in the generated shader. | Buffertable: Uniform arrays and/or samplerBuffers which pass arrays of values into the shader. | Texturetable: TOP inputs that are fed into the shader and referenced with sampler* uniforms. | Variabletable: Definitions of variables that the operator can provide to other operators. See Variables. | Referencetable: Definitions of references to variables from other operators. This is only used by variableReference. | Tagtable: Tags that indicate whether this operator uses certain renderer features like shadows or lights or surface color attributes. | Generatedmacrotables : Optional list of additional DATs handled like Macrotable. This is typically used for tables that are generated by helper components inside the ROP. | Paramgrouptable: Definitions of parameters that are passed into the shader as either uniforms, macros, or specialization constants. | Callbacks: Python functions which can be called on certain events like the initial creation of the ROP. | . | Metadata (mostly used for the palette and other tools) . | Help: Optional DAT that contains help text. This is stripped out in the build process and moved to the documentation site. | Helpurl: Link to the page on the documentation site for this ROP. | Displaycategory: Category where the ROP is listed in the palette. | Shortcuts: Keyboard shortcuts for the palette search box. | Keywords: Keywords that are used when searching for ROPs in the palette. | . | . ",
    "url": "/raytk/development/rop-structure/#rop-definitions",
    "relUrl": "/development/rop-structure/#rop-definitions"
  },"513": {
    "doc": "ROP Structure",
    "title": "Generated Definition tables",
    "content": "The opDefinition component produces a definition table row with the main properties of the ROP, added to the combined rows of the attached inputs of the ROP. There are several categories of information about a ROP, produced by the opDefinition: . | Inline definition table fields . | These are included in the row that’s output by the ROP. | They’re also included in the full definition table within the opDefinition, along with additional fields. | They are the core propreties of the ROP, along with paths to other OPs that contain other categories of information. | name: globally unique name for the ROP, based on the path. | path: path to the ROP. | opType: identifies the type of ROP, and is derived from the path of the clone master used to create a ROP. | coordType: the type of coordinates that the ROP’s function accepts. | returnType: the type of value the that the ROP’s function returns. | contextType: the type of context that the ROP’s function expects along with the coordinates. | tags: indicators that the OP uses certain features like shadows or surface colors. | definitionPath: path to the DAT that contains the full table of ROP properties. | . | Local definition table fields . | These are only included within a single-ROP table inside the opDefinition. | opVersion: version of that particular type of ROP. | toolkitVersion: version of the toolkit. This is used for validation. | paramSource: path to the CHOP that holds the values of runtime parameters. | constantParamSource: path to the CHOP that holds the values of specialization constant parameters. These are processed separately from runtime parameters to avoid unnecessary cooking. | paramVectors: path to a CHOP with the runtime parameters, rearranged into 4 vector channels. This will eventually be used to avoid having to reorder all the parameters in shaderBuilder. | libraryNames: names of common shared GLSL libraries and/or paths to ROP-local libraries. | . | RopState . | This is a structured object stored as JSON in a DAT inside the opDefinition. | It holds prepared blocks of code. | It also holds more complex data like lists. | The shaderBuilder loads the object from the JSON while generating shader code and supporting tables. | . | Value CHOPs . | These hold the current values of the ROP’s parameters. | The shaderBuilder combines the channels from these for all ROPs in the scene to pass in as uniforms and/or specialization constants. | The values for specialization constants are stored in a separate CHOP than those used as runtime parameters, so that changes to runtime parameters don’t cause things related to specialization constants to cook. | . | . ",
    "url": "/raytk/development/rop-structure/#generated-definition-tables",
    "relUrl": "/development/rop-structure/#generated-definition-tables"
  },"514": {
    "doc": "ROP Structure",
    "title": "ROP Functions and GLSL Types",
    "content": "Each ROP has a main function that it contributes to the shader. All of these functions take in two parameters: coordinates, and context, and return a single value. ReturnT sphere1(CoordT p, ContextT ctx) { return createSdf(length(p)); } . Coordinate types . | vec3: 3D coordinates, such as a position along a ray as it is marching along through space. | vec2: 2D coordinates, such as screen-space UV coordinates, texture coordinates, or positions used for 2D SDFs. | float: 1D coordinates, which can be used for things like looking up how much to apply an effect based on distance from some point, or how to blend between two values. | . Context types . Each ROP function takes a second parameter that is used to pass along additional information about the context in which the function is being called. ROPs often don’t make use of this, but they need to pass it along when calling other ROPs since they might need it. | Context: This is the most common type, which is used when evaluating an SDF during raymarching. It contains fields like iteration, which is used in cases like the reflect ROP so its input can do something different depending on which side of the reflection plane it’s on. | LightContext: Used by light ROPs to pass along information about the surface that it is being applied to and the normal direction. | MaterialContext: Used by materials to pass along information about the surface that it is being applied to, the light that’s being used, and where the ray that hit it came from. | CameraContext: Used by cameras to pass along information like the output resolution. | RayContext: Used by ray modifiers that bend or alter rays. | . Return types . Each ROP function produces a single return value. | Sdf: The result of a signed distance function (SDF), representing what the closest shape is and how far it is from the ray position. It also contains information like which material to use. | float: A single numeric value. This can be used for value fields that determine how much of something to apply based on a position in space. | vec4: 4 numeric values. This can be used for vector fields or colors. | Ray: A position in 3D space and a direction. Cameras return one of these for each pixel in the ouput. | Light: Information about how much color is provided by a light to a surface. | . ",
    "url": "/raytk/development/rop-structure/#rop-functions-and-glsl-types",
    "relUrl": "/development/rop-structure/#rop-functions-and-glsl-types"
  },"515": {
    "doc": "Shader Builder",
    "title": "Shader Builder",
    "content": "The shaderBuilder component is included in every output / renderer operator. It is responsible for producing all the things that the render ROP needs to execute the shader in a GLSL TOP. | Collect information about all the ROPs in a scene. | Generate the complete shader. | Collect the parameters, texture sources, specialization constants, etc. that the shader relies on. | . ",
    "url": "/raytk/development/shader-builder/",
    "relUrl": "/development/shader-builder/"
  },"516": {
    "doc": "Shader Builder",
    "title": "Shader Config",
    "content": "TODO . ",
    "url": "/raytk/development/shader-builder/#shader-config",
    "relUrl": "/development/shader-builder/#shader-config"
  },"517": {
    "doc": "Shader Builder",
    "title": "Definition Processing",
    "content": "Definition processing is applied to the incoming table of ROP definitions. | Gather fields from each ROP’s full definition table and add them to the inline columns. | Resolve coord / context / return types. See (Type Handling)[/raytk/development/type-handling/]. | Reverse rows so that every ROP’s dependencies come after it in the table. | Apply name simplification (depend on the render config). | . ",
    "url": "/raytk/development/shader-builder/#definition-processing",
    "relUrl": "/development/shader-builder/#definition-processing"
  },"518": {
    "doc": "Shader Builder",
    "title": "Runtime Parameters",
    "content": "The runtime parameters from all ROPs are collected, then arranged into 4-part tuples. For parameters that are already tuples, they’re just used as they are (with spacers if needed to fill them to 4 parts). For parameters that are single values, they’re combined into tuples when possible. The resulting CHOP is then passed to the GLSL TOP as a uniform array of vec4. ",
    "url": "/raytk/development/shader-builder/#runtime-parameters",
    "relUrl": "/development/shader-builder/#runtime-parameters"
  },"519": {
    "doc": "Shader Builder",
    "title": "Constant Parameters",
    "content": "The parameters configured as specialization constants from all ROPs are collected into a single CHOP. Then each one is added to the GLSL TOP as a separate specialization constant. ",
    "url": "/raytk/development/shader-builder/#constant-parameters",
    "relUrl": "/development/shader-builder/#constant-parameters"
  },"520": {
    "doc": "Shader Builder",
    "title": "Parameter Aliases",
    "content": "For each parameter, a macro is generated that refers to its position in the params array and the relevant vector field (XYZW). For each tuplet, a macro is generated that refers to either the vector in the params array, with a type wrapper to reduce it to the relevant number of parts (e.g. vec2). ",
    "url": "/raytk/development/shader-builder/#parameter-aliases",
    "relUrl": "/development/shader-builder/#parameter-aliases"
  },"521": {
    "doc": "Shader Builder",
    "title": "Macros",
    "content": "TODO . ",
    "url": "/raytk/development/shader-builder/#macros",
    "relUrl": "/development/shader-builder/#macros"
  },"522": {
    "doc": "Shader Builder",
    "title": "Buffers",
    "content": "TODO . ",
    "url": "/raytk/development/shader-builder/#buffers",
    "relUrl": "/development/shader-builder/#buffers"
  },"523": {
    "doc": "Shader Builder",
    "title": "Textures",
    "content": "Textures from the RopStates of all ROPs are collected into a table, so they can be connected as inputs to the GLSL TOP. ",
    "url": "/raytk/development/shader-builder/#textures",
    "relUrl": "/development/shader-builder/#textures"
  },"524": {
    "doc": "Shader Builder",
    "title": "Output Buffers",
    "content": "Each enabled output buffer on the ROP is identified and a declaration for it is injected into the shader. The number of each buffer is passed to the parent renderer, so it can enable that many outputs for the GLSL TOP. ",
    "url": "/raytk/development/shader-builder/#output-buffers",
    "relUrl": "/development/shader-builder/#output-buffers"
  },"525": {
    "doc": "Shader Builder",
    "title": "Variables and References",
    "content": "TODO . ",
    "url": "/raytk/development/shader-builder/#variables-and-references",
    "relUrl": "/development/shader-builder/#variables-and-references"
  },"526": {
    "doc": "Shader Builder",
    "title": "Library Includes",
    "content": "There is a set of commonly used shared libraries that ROPs can indicate that they use. For each of these that is used by at least one ROP in the scene, either an #include directive is injected into the code referring to its DAT, or the contents of that DAT is directly injected into the shader (depending on the shader configuration). For less commonly used libraries, ROPs may include a copy within themselves and include its path so the shaderBuilder can include it. These are deduplicated based on their text content to avoid declaration conflicts and redundant code. ",
    "url": "/raytk/development/shader-builder/#library-includes",
    "relUrl": "/development/shader-builder/#library-includes"
  },"527": {
    "doc": "Shader Builder",
    "title": "Code Processing",
    "content": "The generated shader is organized into a number of sections. Depending on the contents of the scene, some of these sections might not be present (e.g. if no textures are used). | Global declarations provided by the renderer. These can provide items accessible from other ROPs. | OP data type aliases/macros. For each ROP, macros are added that refer to the coord / context / return types (for use in declarations), as well as macros indicating which types are used (for preprocessor usage). | Macros from OPs and/or the renderer | Library includes (or the full contents of libraries depening on shader config) | Predeclarations provided by the renderer | Parameter alias macros | Texture declarations / alias macros | Buffer declarations | Material ID declarations | Output buffer declarations | Variable declarations | Output buffer initialization function: zero out output buffers in case they are left unassigned. | Global declarations from each ROP | Initialization function with init block from each ROP | ROP Functions | Renderer body code | . ",
    "url": "/raytk/development/shader-builder/#code-processing",
    "relUrl": "/development/shader-builder/#code-processing"
  },"528": {
    "doc": "Shader Builder",
    "title": "Validation",
    "content": "TODO . ",
    "url": "/raytk/development/shader-builder/#validation",
    "relUrl": "/development/shader-builder/#validation"
  },"529": {
    "doc": "Data Type Handling",
    "title": "Data Type Handling",
    "content": "There are several categories of data types used in RayTK: . | Coordinates (1D, 2D, 3D) | Return values (Sdf surface info, float, vector, etc.) | Contexts (Context, MaterialContext, etc) | . When building the shader, each ROP ends up using exactly one type from each category. In other words, a ROP is a function, taking in a coordinate and a context, and returning a value. When a ROP has an input ROP, it’s responsible for providing a coordinate and a context to that input when it calls it. And then it uses the return value from that input. ",
    "url": "/raytk/development/type-handling/",
    "relUrl": "/development/type-handling/"
  },"530": {
    "doc": "Data Type Handling",
    "title": "Contexts",
    "content": "Contexts are a secondary piece of data passed into each ROP’s function with supplemental info, providing by the ROP that’s calling it. There are several types of contexts, including: . | Context: the standard data passed while marching a ray | MaterialContext: data with properties of an sdf surface like surface normal, assigned color, material id, uv coordinates. When materials are calculating colors, they can use those properties. | . ",
    "url": "/raytk/development/type-handling/#contexts",
    "relUrl": "/development/type-handling/#contexts"
  },"531": {
    "doc": "Data Type Handling",
    "title": "The Simple Case",
    "content": "In the most simple case, each ROP declares which specific type it’s going to use for each category. For example, a boxSdf will always use 3D coordinates, will produce Sdf surface info, and will use the standard Context. Why This Is Problematic . This is nice and simple but it imposes limitations. It means that the ROP can only be attached to certain inputs of certain types of ROPs. For a boxSdf, it’s easy, but for something like a waveField, it might be connected to something expecting 2D coordinates, or it might be used within a material (using MaterialContext). In early versions of RayTK, this meant that many ROPs had a Context type parameter and a Coordinate type parameter. And those had to be set to the types expected by whatever the ROP gets connected to. ",
    "url": "/raytk/development/type-handling/#the-simple-case",
    "relUrl": "/development/type-handling/#the-simple-case"
  },"532": {
    "doc": "Data Type Handling",
    "title": "Type Inheritance",
    "content": "For many ROPs, they don’t really care what type of coordinates they or what return value they produce. A rotate might produce a vector or an Sdf, depending on its input. And it could use either 2D or 3D coordinates. So ROPs can specify that they inherit whatever coordinate or return (or context) type is connected to their input. They may also limit which types it allows, in other words saying: “I use whatever type of coordinates my input uses, but it has to be either 2D or 3D”. To represent this, in the definition produced by a rotate would reference which ROP’s coordinate type it uses. This reference is resolved down to a specific type later in the process. ",
    "url": "/raytk/development/type-handling/#type-inheritance",
    "relUrl": "/development/type-handling/#type-inheritance"
  },"533": {
    "doc": "Data Type Handling",
    "title": "Multi-Types",
    "content": "Type inheritance involves types flowing downward, from inputs to outputs. But what if an input ROP says that it could use one of several possible types? . For example, constantField doesn’t care what type of coordinates or context it gets since it doesn’t use them anyway. To handle that, it specifies several possible coordinate types, and several possible context types. ",
    "url": "/raytk/development/type-handling/#multi-types",
    "relUrl": "/development/type-handling/#multi-types"
  },"534": {
    "doc": "Data Type Handling",
    "title": "Type Restriction",
    "content": "While the constantField could accept any type of coordinate, whatever it’s connected to might have more specific requirements. For example, if it was connected to the “Size” input on a boxSdf, the boxSdf will only be able to provide it with 3D coordinates. (This would be an unnecessary use of a constantField, but it’s useful as an example.) . So as the boxSdf takes in the definition from the constantField, it restricts which types the constantField could get. In this case it would be restricting it down to only one type, but it could be several. By the time the ROP definitions get to the shaderBuilder inside a renderer, each one needs to have its types restricted to a single type per category. So each input on a renderer has rules saying which type it prefers in the case where there could be multiple. For example, render2D can take an input that says “I’m either 2D or 1D”. But in that case, it picks “2D” since it prefers that over 1D. But if its input only supports 1D, then it would use that instead. ",
    "url": "/raytk/development/type-handling/#type-restriction",
    "relUrl": "/development/type-handling/#type-restriction"
  },"535": {
    "doc": "Data Type Handling",
    "title": "Type Resolution",
    "content": "The shaderBuilder gets a table of ROP definitions, with columns for coord type, context type, and return type. At this point it finds any that are references (“I use whatever coord type X is using”) and replaces those with the specific type that the target of the reference ended up with (after all the restrictions reducing it to a single type). ",
    "url": "/raytk/development/type-handling/#type-resolution",
    "relUrl": "/development/type-handling/#type-resolution"
  },"536": {
    "doc": "Data Type Handling",
    "title": "How Types Are Used in ROP Code",
    "content": "The implication of this whole restriction and resolution process is that a ROP might not know ahead of time what specific types it’s going to use. But the shaderBuilder has the final types for every ROP. So it generates a set of preprocessor macros like: . #define someOperator1_COORD_TYPE_vec3 #define someOperator1_CoordT vec3 #define someOperator1_CONTEXT_TYPE_Context #define someOperator1_ContextT Context #define someOperator1_RETURN_TYPE_float #define someOperator1_ReturnT float . The ROP’s code can then use those to switch between different blocks of code, or to swap in placeholder types. The original source code for an operator would look like this: . ReturnT thismap(CoordT p, ContextT ctx) { CoordT p2 = p * 2.; // A variable using the same type as the coordinates. ReturnT res = inputOp1(p2, ctx); #ifdef THIS_RETURN_TYPE_Sdf // Code that's only used when producing Sdf results res.color = vec4(1, 2, 3, 1); #endif return res; } . Before being added to the final shader, those placeholders (ReturnT, THIS_RETURN_TYPE_Sdf) would be replaced with references to the generated macros (someOperator1_ReturnT, someOperator1_RETURN_TYPE_Sdf). ",
    "url": "/raytk/development/type-handling/#how-types-are-used-in-rop-code",
    "relUrl": "/development/type-handling/#how-types-are-used-in-rop-code"
  },"537": {
    "doc": "Variable Handling",
    "title": "Variable Handling",
    "content": " ",
    "url": "/raytk/development/variables/",
    "relUrl": "/development/variables/"
  },"538": {
    "doc": "Variable Handling",
    "title": "What Are Variables?",
    "content": "Many ROPs support what are known as “variables”. These are values which a ROP makes available to upstream operators (anything connected to one of its inputs or to one of those inputs’ inputs, and so on). Variables provide context-specific information that can be used to base fields on how and where they are being used. For example, torusSdf provides a variable for the angle around its center (normalized to a 0..1 range). This could be referenced by a waveField controlling the thickness of the torus. No matter where the torus is placed, or what axis its on, that waveField would always be using the correct value. ",
    "url": "/raytk/development/variables/#what-are-variables",
    "relUrl": "/development/variables/#what-are-variables"
  },"539": {
    "doc": "Variable Handling",
    "title": "Referencing Variables",
    "content": "The variableReference ROP takes a reference to a provider ROP and the name of a variable, and returns the value when called. It does this by specifying a table of references (though there’s only one item in the table), which gets included in the ROP’s definition and passed to the shaderBuilder. It is technically possible for there to be other types of ROPs that use references, but in practice, it’s only variableReference (for now). ",
    "url": "/raytk/development/variables/#referencing-variables",
    "relUrl": "/development/variables/#referencing-variables"
  },"540": {
    "doc": "Variable Handling",
    "title": "Connecting Variables and References",
    "content": "After pulling together all the ROPs in the scene, the shaderBuilder ends up with two tables: variables and references. It matches references to variables, and strips out any variables that aren’t referenced. Then it takes the results and generates code for them: . | Preprocessor macros, which indicate which variables should be provided, what their types are, and helpers for converting them to the relevant supported return type. | Global variables, which hold the values of the variables. | . ",
    "url": "/raytk/development/variables/#connecting-variables-and-references",
    "relUrl": "/development/variables/#connecting-variables-and-references"
  },"541": {
    "doc": "Variable Handling",
    "title": "Providing Variables",
    "content": "A ROP can provide a table that lists out the variables that it can provide, with names and data types. Within the code for a ROP that provides a variable, there will be a conditional block that calculates the value and puts it into the global variable. #ifdef THIS_EXPOSE_normangle THIS_normangle = atan(p.x, p.z) / TAU + .5; #endif . This allows operators to skip calculations that might not be needed, for variables that aren’t referenced. ",
    "url": "/raytk/development/variables/#providing-variables",
    "relUrl": "/development/variables/#providing-variables"
  },"542": {
    "doc": "Variable Handling",
    "title": "Where Variables Can Be Used",
    "content": "The rules around where variables can be used all come down to this: a variable has to be populated before it can be used. This means that (with certain exceptions) all paths from a variableReference to a render have to pass through the operator that provides the variable for that reference. In many cases, a ROP will have several inputs, but only some of them will be able to use certain variables. For example, reflect provides a side variables indicating which side the current position is on. However, the input that determines where the reflection plane is can’t use that variable, since it can’t be determined until after the reflection plane is chosen. But the primary input, if it was an SDF for example, would be able to use the side since it would have already been determined by the time the reflect calls the SDF. ",
    "url": "/raytk/development/variables/#where-variables-can-be-used",
    "relUrl": "/development/variables/#where-variables-can-be-used"
  }
}
